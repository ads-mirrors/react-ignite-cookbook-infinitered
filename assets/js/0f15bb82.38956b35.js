"use strict";(self.webpackChunkignite_cookbook=self.webpackChunkignite_cookbook||[]).push([[7568],{5664:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=n(7624),i=n(2172);const o={title:"Universal E2E Testing with Detox and Playwright",description:"How to re-use tests across iOS, Android, and Web with Detox and Playwright.",tags:["Detox","Playwright","testing"],last_update:{author:"Joshua Yoes"},publish_date:new Date("2025-02-12T00:00:00.000Z")},r="Universal E2E Testing with Detox and Playwright",a={id:"recipes/UniversalE2ETesting",title:"Universal E2E Testing with Detox and Playwright",description:"How to re-use tests across iOS, Android, and Web with Detox and Playwright.",source:"@site/docs/recipes/UniversalE2ETesting.md",sourceDirName:"recipes",slug:"/recipes/UniversalE2ETesting",permalink:"/docs/recipes/UniversalE2ETesting",draft:!1,unlisted:!1,tags:[{label:"Detox",permalink:"/docs/tags/detox"},{label:"Playwright",permalink:"/docs/tags/playwright"},{label:"testing",permalink:"/docs/tags/testing"}],version:"current",lastUpdatedBy:"Joshua Yoes",lastUpdatedAt:1739470979,formattedLastUpdatedAt:"Feb 13, 2025",frontMatter:{title:"Universal E2E Testing with Detox and Playwright",description:"How to re-use tests across iOS, Android, and Web with Detox and Playwright.",tags:["Detox","Playwright","testing"],last_update:{author:"Joshua Yoes"},publish_date:"2025-02-12T00:00:00.000Z"},sidebar:"mainSidebar",previous:{title:"TypeScript baseUrl Configuration",permalink:"/docs/recipes/TypeScriptBaseURL"},next:{title:"Scrolling to a location that hasn't been rendered using FlatList or SectionList",permalink:"/docs/recipes/UnrenderedItemInScrollView"}},l={},c=[{value:"Should you cook this up?",id:"should-you-cook-this-up",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Install Detox",id:"install-detox",level:2},{value:"Install Playwright",id:"install-playwright",level:2},{value:"Add <code>e2e</code> Folder Changes for <code>Login.test.ts</code>",id:"add-e2e-folder-changes-for-logintestts",level:2},{value:"Folder Structure (simplified)",id:"folder-structure-simplified",level:3},{value:"Login Tests",id:"login-tests",level:3},{value:"Shared Entry",id:"shared-entry",level:3},{value:"Screen interfaces",id:"screen-interfaces",level:3},{value:"Detox Login Screen",id:"detox-login-screen",level:3},{value:"Detox Welcome Screen",id:"detox-welcome-screen",level:3},{value:"Detox Setup",id:"detox-setup",level:3},{value:"Detox Test Entry",id:"detox-test-entry",level:3},{value:"Playwright Login Screen",id:"playwright-login-screen",level:3},{value:"Playwright Welcome Screen",id:"playwright-welcome-screen",level:3},{value:"Playwright Test Entry",id:"playwright-test-entry",level:3},{value:"Playwright Setup",id:"playwright-setup",level:3},{value:"Run Detox Tests",id:"run-detox-tests",level:2},{value:"Run Playwright Tests",id:"run-playwright-tests",level:2},{value:"Gotchas to look out for",id:"gotchas-to-look-out-for",level:2},{value:"That&#39;s it! Write more tests!",id:"thats-it-write-more-tests",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"universal-e2e-testing-with-detox-and-playwright",children:"Universal E2E Testing with Detox and Playwright"}),"\n",(0,s.jsx)(t.p,{children:"So we all know that writing UI E2E tests suck right? It's hard to know if an assertion failure is a bug in your app or a bug in your test. They are slow to run, and they are brittle against changes as new features get developed. And as they grow in number, they often become a mess because they do not have a planned architecture."}),"\n",(0,s.jsx)(t.p,{children:"But they can also be too useful to ignore. A lot of bad deployments have been stopped by a single E2E test that caught a critical bug. So how can we make maintaining them less painful?"}),"\n",(0,s.jsxs)(t.p,{children:["This recipe uses a boring but easy to understand design pattern, called the Page Object Model. If you give it ",(0,s.jsx)(t.a,{href:"https://www.google.com/search?q=page+object+model",children:"a Google search"}),", you will find that most testing tool have a documentation page dedicated to this pattern. We can leverage this fact to write our tests so that multiple testing frameworks can run the same test files, so we can re-use our tests across iOS, Android, and web."]}),"\n",(0,s.jsxs)(t.p,{children:["In order to accomplish this, we are going to setup Playwright and Detox to co-exist in the same Ignite project. We'll add an ",(0,s.jsx)(t.code,{children:"e2e"})," folder containing shared page-object models and test fixtures. Then we'll configure our test files so we can run the same test code in ",(0,s.jsx)(t.strong,{children:"iOS"})," and ",(0,s.jsx)(t.strong,{children:"Android"})," (Detox) or ",(0,s.jsx)(t.strong,{children:"Web"})," (Playwright). After we are done, we will be left with some basic tests and a clear architecture for writing new tests and page object models."]}),"\n",(0,s.jsx)(t.h2,{id:"should-you-cook-this-up",children:"Should you cook this up?"}),"\n",(0,s.jsx)(t.p,{children:"This recipe is for you if:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"You have tests for one platform using page object models and you want to re-use them on another platform"}),"\n",(0,s.jsx)(t.li,{children:"You are starting to add tests to a new project and both web and mobile are critical flows for your users."}),"\n",(0,s.jsx)(t.li,{children:"You have a large team and want to use an simple testing architecture that is familiar to many developers."}),"\n",(0,s.jsx)(t.li,{children:"You want to write all your tests for each platforms in a single language (JavaScript / TypeScript)."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,s.jsx)(t.p,{children:"You can start with an existing Ignite project, or create a new one using:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"npx ignite-cli@latest new PizzaApp\ncd PizzaApp\n"})}),"\n",(0,s.jsx)(t.h2,{id:"install-detox",children:"Install Detox"}),"\n",(0,s.jsxs)(t.p,{children:["Follow the official ",(0,s.jsx)(t.a,{href:"https://wix.github.io/Detox/docs/introduction/project-setup",children:"Detox Getting Started Guide"}),". As of writing this, you will:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Install the Detox CLI as a dev dependency (",(0,s.jsx)(t.code,{children:"yarn add -D detox"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:["Init via ",(0,s.jsx)(t.code,{children:"yarn detox init"})," to get the necessary config files like ",(0,s.jsx)(t.code,{children:".detoxrc.js"})," and ",(0,s.jsx)(t.code,{children:"e2e/jest.config.js"})]}),"\n",(0,s.jsx)(t.li,{children:"Remove any generated test files, we will create our own later."}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"This guide assumes that you will use yarn 1 as your package manager. But if don't use that, you can use ChatGPT or your brain to convert the commands to your package manager of choice."})}),"\n",(0,s.jsx)(t.h2,{id:"install-playwright",children:"Install Playwright"}),"\n",(0,s.jsxs)(t.p,{children:["Follow the official ",(0,s.jsx)(t.a,{href:"https://playwright.dev/docs/intro#installing-playwright",children:"Playwright Intro Guide"}),". This typically looks like:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Init via ",(0,s.jsx)(t.code,{children:"yarn create playwright"}),", which should create a ",(0,s.jsx)(t.code,{children:"playwright.config.ts"}),", updates your ",(0,s.jsx)(t.code,{children:"package.json"})," scripts, and optionally install browsers. ",(0,s.jsx)(t.code,{children:"Make sure to set Where to put your end-to-end tests?"})," to ",(0,s.jsx)(t.code,{children:"e2e/tests"})]}),"\n",(0,s.jsxs)(t.li,{children:["Run ",(0,s.jsx)(t.code,{children:"yarn playwright install"})," to install browsers if you haven't already"]}),"\n",(0,s.jsxs)(t.li,{children:["Make sure your ",(0,s.jsx)(t.code,{children:"playwright.config.ts"})," has the ",(0,s.jsx)(t.code,{children:"testDir"})," to point to a ",(0,s.jsx)(t.code,{children:"e2e/tests"})," folder, we will create this next:"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:' export default defineConfig({\n-  testDir: "./tests/playwright",\n+  testDir: "./e2e/tests",\n   /* Run tests in files in parallel */\n   fullyParallel: true,\n'})}),"\n",(0,s.jsxs)(t.h2,{id:"add-e2e-folder-changes-for-logintestts",children:["Add ",(0,s.jsx)(t.code,{children:"e2e"})," Folder Changes for ",(0,s.jsx)(t.code,{children:"Login.test.ts"})]}),"\n",(0,s.jsxs)(t.p,{children:["Below is a minimal example of our test setup. The structure uses a single test definition that references environment-agnostic fixtures. Detox code lives in ",(0,s.jsx)(t.code,{children:"e2e/detox/"}),", Playwright code in ",(0,s.jsx)(t.code,{children:"e2e/playwright/"}),", and shared interfaces in ",(0,s.jsx)(t.code,{children:"e2e/screens.ts"}),". Then each test file imports from a single ",(0,s.jsx)(t.code,{children:"entry.ts"})," which picks Detox or Playwright at runtime."]}),"\n",(0,s.jsx)(t.h3,{id:"folder-structure-simplified",children:"Folder Structure (simplified)"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"e2e\n\u251c\u2500 detox\n\u2502  \u251c\u2500 screens\n\u2502  \u2502  \u251c\u2500 LoginScreen.ts\n\u2502  \u2502  \u2514\u2500 WelcomeScreen.ts\n\u2502  \u251c\u2500 entry.ts\n\u2502  \u2514\u2500 setup.ts\n\u251c\u2500 playwright\n\u2502  \u251c\u2500 screens\n\u2502  \u2502  \u251c\u2500 LoginScreen.ts\n\u2502  \u2502  \u2514\u2500 WelcomeScreen.ts\n\u2502  \u251c\u2500 entry.ts\n\u2502  \u2514\u2500 setup.ts\n\u251c\u2500 tests\n\u2502  \u2514\u2500 Login.test.ts\n\u251c\u2500 screens.ts\n\u251c\u2500 entry.ts\n\u2514\u2500 jest.config.js\n"})}),"\n",(0,s.jsx)(t.h3,{id:"login-tests",children:"Login Tests"}),"\n",(0,s.jsx)(t.p,{children:'Notice how there aren\'t a lot of imports here, instead our page object model "imports" are provided to the test function as an object. This is the secret sauce to using the same test files across multiple environments. More on that later!'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/tests/Login.test.ts"',children:'import { test } from "../entry";\n\ntest("Open up our app and use the default credentials to login and navigate to the demo screen", async ({\n  loadApp,\n  loginScreen,\n  welcomeScreen,\n}) => {\n  await loadApp();\n  await loginScreen.login();\n  await welcomeScreen.launch();\n});\n'})}),"\n",(0,s.jsx)(t.h3,{id:"shared-entry",children:"Shared Entry"}),"\n",(0,s.jsxs)(t.p,{children:["A single entry point chooses which environment to load. It has a utility ",(0,s.jsx)(t.code,{children:"test"})," that's either Detox's or Playwright's \"test\" function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/entry.ts"',children:'import type { Fixtures } from "./screens";\n\n/** Check for runtime globals that we are in a detox environment  */\nexport const isDetoxTestEnv = () =>\n  // @ts-ignore\n  typeof device !== "undefined";\n\n/** Check for runtime globals that we are in a playwright environment */\nexport const isPlaywrightTestEnv = () =>\n  // @ts-ignore\n  globalThis._playwrightInstance !== undefined;\n\n/** Our library-agnostic test function */\nexport type Test = (\n  name: string,\n  fn: (fixtures: Fixtures) => Promise<void>\n) => void;\n\n/**\n * This test function is a little funky, but it ensures that we don\'t accidentally\n * import playwright code into a detox environment, or vice versa.\n */\nexport const test: Test = (() => {\n  const testEnvsLoaded = [isDetoxTestEnv(), isPlaywrightTestEnv()].filter(\n    Boolean\n  ).length;\n\n  if (testEnvsLoaded !== 1) {\n    throw new Error(\n      `${testEnvsLoaded} test environments loaded. Only one is allowed. Check the isTestEnv functions to make sure they check for globals that are specific only to their test environment`\n    );\n  }\n\n  if (isDetoxTestEnv()) {\n    return require("./detox/entry").test;\n  }\n  if (isPlaywrightTestEnv()) {\n    return require("./playwright/entry").test;\n  }\n\n  throw new Error(\n    "Unknown test environment. Check the isTestEnv functions to make sure they check for globals that are specific only to their test environment"\n  );\n})();\n'})}),"\n",(0,s.jsx)(t.h3,{id:"screen-interfaces",children:"Screen interfaces"}),"\n",(0,s.jsx)(t.p,{children:'Define your "agnostic" page objects as TypeScript interfaces. You should eventually have a page object model interface for each screen in your app, but for now we just have a login screen and a welcome screen.'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/screens.ts"',children:"export interface ILoginScreen {\n  login(): Promise<void>;\n}\n\nexport interface IWelcomeScreen {\n  launch(): Promise<void>;\n}\n\n/** A fixture of all the page object models we can use in our tests */\nexport type Fixtures = {\n  loadApp: () => Promise<void>;\n  loginScreen: ILoginScreen;\n  welcomeScreen: IWelcomeScreen;\n  // ... you can add more as needed\n};\n"})}),"\n",(0,s.jsx)(t.h3,{id:"detox-login-screen",children:"Detox Login Screen"}),"\n",(0,s.jsxs)(t.p,{children:["Behold! An implementation! This is where we implement the actual logic of our page object model. Because we are in the detox directory and we are careful loading only one test environment at a time in our ",(0,s.jsx)(t.code,{children:"e2e/entry.ts"})," file, we can import Detox specific code here."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/detox/screens/LoginScreen.ts"',children:'import { expect, element, by } from "detox";\nimport type { ILoginScreen } from "../../screens";\n\nexport class DetoxLoginScreen implements ILoginScreen {\n  async login() {\n    await expect(element(by.text("Log In"))).toBeVisible();\n    await element(by.text("Tap to log in!")).tap();\n  }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"detox-welcome-screen",children:"Detox Welcome Screen"}),"\n",(0,s.jsx)(t.p,{children:"Behold! Another implementation!"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/detox/screens/WelcomeScreen.ts"',children:'import { expect, element, by } from "detox";\nimport type { IWelcomeScreen } from "../../screens";\n\nexport class DetoxWelcomeScreen implements IWelcomeScreen {\n  async launch() {\n    await expect(\n      element(by.text("Your app, almost ready for launch!"))\n    ).toBeVisible();\n    await element(by.text("Let\'s go!")).tap();\n    await expect(\n      element(by.text("Components to jump start your project!"))\n    ).toBeVisible();\n  }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"detox-setup",children:"Detox Setup"}),"\n",(0,s.jsx)(t.p,{children:"This file handles launching the app differently based on your build configuration:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"For release builds: Simply launches the app normally"}),"\n",(0,s.jsxs)(t.li,{children:["For debug builds: Handles launching through Expo Dev Client and deep linking","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"For local development: Links to the local Metro bundler"}),"\n",(0,s.jsx)(t.li,{children:"For testing EAS updates: Links to the published update URL"}),"\n",(0,s.jsx)(t.li,{children:"Handles platform-specific launch requirements (iOS needs an extra step)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/detox/setup.ts"',children:'import { device } from "detox";\nimport { resolveConfig } from "detox/internals";\nimport type { AppJSONConfig } from "@expo/config";\nconst appConfig: AppJSONConfig = require("../../app.json");\n\ntype Platform = ReturnType<typeof device.getPlatform>;\n\nexport async function detoxLoadApp() {\n  const config = await resolveConfig();\n  const platform = device.getPlatform();\n  const isDebugConfig = config.configurationName.split(".").at(-1) === "debug";\n  if (isDebugConfig) {\n    return await openAppForDebugBuild(platform);\n  } else {\n    return await device.launchApp({\n      newInstance: true,\n    });\n  }\n}\n\nasync function openAppForDebugBuild(platform: Platform) {\n  const deepLinkUrl = process.env.EXPO_USE_UPDATES\n    ? // Testing latest published EAS update for the test_debug channel\n      getDeepLinkUrl(getLatestUpdateUrl())\n    : // Local testing with packager\n      getDeepLinkUrl(getDevLauncherPackagerUrl(platform));\n\n  if (platform === "ios") {\n    await device.launchApp({\n      newInstance: true,\n    });\n    await sleep(1000);\n    await device.openURL({\n      url: deepLinkUrl,\n    });\n  } else {\n    await device.launchApp({\n      newInstance: true,\n      url: deepLinkUrl,\n    });\n  }\n\n  await sleep(1000);\n}\n\nconst getAppId = () => appConfig?.expo?.extra?.eas?.projectId ?? "";\n\nconst getAppSchema = () => appConfig?.expo?.scheme ?? "";\n\nconst getDeepLinkUrl = (url: string) =>\n  `exp+${getAppSchema()}://expo-development-client/?url=${encodeURIComponent(\n    url\n  )}`;\n\nconst getDevLauncherPackagerUrl = (platform: Platform) =>\n  `http://localhost:8081/index.bundle?platform=${platform}&dev=true&minify=false&disableOnboarding=1`;\n\nconst getLatestUpdateUrl = () =>\n  `https://u.expo.dev/${getAppId()}?channel-name=test_debug&disableOnboarding=1`;\n\nconst sleep = (t: number) => new Promise((res) => setTimeout(res, t));\n'})}),"\n",(0,s.jsx)(t.h3,{id:"detox-test-entry",children:"Detox Test Entry"}),"\n",(0,s.jsx)(t.p,{children:'This is the magic for how to run the test files in Detox! We create a "fixture" of all the page objects that our tests can use and provides them to the test function. Since Detox uses Jest as the test runner, we want to use the global test function and then wrap it to provide the fixtures.'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/detox/entry.ts"',children:'import { DetoxWelcomeScreen } from "./screens/WelcomeScreen";\nimport { DetoxLoginScreen } from "./screens/LoginScreen";\nimport type { Fixtures } from "../screens";\nimport type { Test } from "../entry";\nimport { detoxLoadApp } from "./setup";\n\nconst fixtures: Fixtures = {\n  loadApp: detoxLoadApp,\n  loginScreen: new DetoxLoginScreen(),\n  welcomeScreen: new DetoxWelcomeScreen(),\n};\n\nexport const test: Test = (name, fn) =>\n  globalThis.test(name, (done) => {\n    fn(fixtures)\n      .then(() => done())\n      .catch(done.fail);\n  });\n'})}),"\n",(0,s.jsx)(t.h3,{id:"playwright-login-screen",children:"Playwright Login Screen"}),"\n",(0,s.jsxs)(t.p,{children:["Our detox code is setup! If you like, you can skip to ",(0,s.jsx)(t.code,{children:"Run Detox Tests"})," section to make sure your tests run and come back to Playwright later. But if you want to see how the other half lives, read on!"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/playwright/screens/LoginScreen.ts"',children:'import { expect, Page } from "@playwright/test";\nimport type { ILoginScreen } from "../../screens";\n\nexport class PlaywrightLoginScreen implements ILoginScreen {\n  constructor(private page: Page) {}\n\n  async login() {\n    await expect(this.page.locator("[data-testid=\'login-heading\']")).toHaveText(\n      "Log In"\n    );\n    await this.page.locator("[data-testid=\'login-button\']").click();\n  }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"playwright-welcome-screen",children:"Playwright Welcome Screen"}),"\n",(0,s.jsx)(t.p,{children:"This is pretty similar to the Detox implementation, but we are using Playwright specific code."}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["Pro-tip: if you use AI tool to help with coding, they are often pretty good at translating one page object implementation to another. ",(0,s.jsx)(t.code,{children:"Please translate this Detox page object to Playwright"})," is a good prompt to start with."]})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/playwright/screens/WelcomeScreen.ts"',children:'import { expect, Page } from "@playwright/test";\nimport type { IWelcomeScreen } from "../../screens";\n\nexport class PlaywrightWelcomeScreen implements IWelcomeScreen {\n  constructor(private page: Page) {}\n\n  async launch() {\n    await expect(\n      this.page.getByText("Your app, almost ready for launch!")\n    ).toBeVisible();\n    await this.page.getByText("Let\'s go!").click();\n    await expect(\n      this.page.getByText("Components to jump start your project!")\n    ).toBeVisible();\n  }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"playwright-test-entry",children:"Playwright Test Entry"}),"\n",(0,s.jsxs)(t.p,{children:["Now let's wrap it all together into a fixture! Playwright can do a ",(0,s.jsx)(t.strong,{children:"lot"})," with fixtures. You can ",(0,s.jsx)(t.a,{href:"https://playwright.dev/docs/test-fixtures",children:"read more about it in their documentation"}),". But we are going to keep it pretty simple for now."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/playwright/entry.ts"',children:'import { test as base } from "@playwright/test";\nimport { playwrightLoadApp } from "./setup";\nimport { PlaywrightLoginScreen } from "./screens/LoginScreen";\nimport { PlaywrightWelcomeScreen } from "./screens/WelcomeScreen";\nimport type { Fixtures } from "../screens";\n\nexport const test = base.extend<Fixtures>({\n  loadApp: async ({ page }, use) => {\n    await use(() => playwrightLoadApp(page));\n  },\n  loginScreen: async ({ page }, use) => {\n    await use(new PlaywrightLoginScreen(page));\n  },\n  welcomeScreen: async ({ page }, use) => {\n    await use(new PlaywrightWelcomeScreen(page));\n  },\n});\n'})}),"\n",(0,s.jsx)(t.h3,{id:"playwright-setup",children:"Playwright Setup"}),"\n",(0,s.jsx)(t.p,{children:"Wow! This is easy. But it's pretty easy to navigate to a web page, so we don't need to do anything fancy here."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="e2e/playwright/setup.ts"',children:'import type { Page } from "@playwright/test";\n\nexport async function playwrightLoadApp(page: Page) {\n  await page.goto("http://localhost:3000");\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"run-detox-tests",children:"Run Detox Tests"}),"\n",(0,s.jsxs)(t.p,{children:["In your ",(0,s.jsx)(t.code,{children:"package.json"}),", add these scripts:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "scripts": {\n    "detox:build:ios:debug": "detox build --c ios.sim.debug",\n    "detox:test:debug": "detox test --configuration ios.sim.debug"\n  }\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Make sure your iOS simulator is running."}),"\n",(0,s.jsx)(t.p,{children:"Then you can build and test:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"yarn detox:build:ios:debug\nyarn start\nyarn detox:test:debug\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["If you have any issues, check ",(0,s.jsx)(t.a,{href:"https://wix.github.io/Detox/docs/introduction/environment-setup",children:"the environment setup"})," or the ",(0,s.jsx)(t.a,{href:"https://wix.github.io/Detox/docs/introduction/debugging",children:"How to Debug"})," articles in the Detox docs."]})}),"\n",(0,s.jsx)(t.h2,{id:"run-playwright-tests",children:"Run Playwright Tests"}),"\n",(0,s.jsxs)(t.p,{children:["In your ",(0,s.jsx)(t.code,{children:"package.json"}),", add these scripts:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "scripts": {\n    "playwright:build": "yarn bundle:web && yarn serve:web",\n    "playwright:test": "yarn playwright test"\n  }\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Then run:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"yarn playwright:build\nyarn playwright:test\n"})}),"\n",(0,s.jsx)(t.p,{children:"This will execute your tests in a browser environment."}),"\n",(0,s.jsx)(t.p,{children:"If you want to use a test runner with a nice UI, you can run:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"yarn playwright:test --ui\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["If you have any issues, check the ",(0,s.jsx)(t.a,{href:"https://playwright.dev/docs/intro",children:"Installation"})," or ",(0,s.jsx)(t.a,{href:"https://playwright.dev/docs/test-intro",children:"Running and debugging tests"})," articles in the Playwright docs."]})}),"\n",(0,s.jsx)(t.h2,{id:"gotchas-to-look-out-for",children:"Gotchas to look out for"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"jest.config.js"})," for your unit tests may get a little eager and start running the tests in the ",(0,s.jsx)(t.code,{children:"e2e"})," folder. You can add this to your ",(0,s.jsx)(t.code,{children:"jest.config.js"})," to ignore the ",(0,s.jsx)(t.code,{children:"e2e"})," folder:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:' module.exports = {\n   preset: "jest-expo",\n   setupFiles: ["<rootDir>/test/setup.ts"],\n+  testPathIgnorePatterns: ["<rootDir>/node_modules/", "<rootDir>/e2e/"],\n }\n'})}),"\n",(0,s.jsxs)(t.p,{children:["As of writing this, ",(0,s.jsx)(t.code,{children:"app/config/config.prod.ts"})," has a placeholder value. For the purposes of this recipe, you can copy the existing ",(0,s.jsx)(t.code,{children:"app/config/config.dev.ts"})," file to ",(0,s.jsx)(t.code,{children:"app/config/config.prod.ts"})," so that the app uses the right ",(0,s.jsx)(t.code,{children:"API_URL"})," in your tests."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:'export default {\n-  API_URL: "CHANGEME",\n+  API_URL: "https://api.rss2json.com/v1/",\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"thats-it-write-more-tests",children:"That's it! Write more tests!"}),"\n",(0,s.jsxs)(t.p,{children:["That wasn't so bad, was it? You now have an E2E test architecture that runs on iOS, Android, and Web! You can add more tests to the ",(0,s.jsx)(t.code,{children:"e2e/tests"})," folder and more page object models to the ",(0,s.jsx)(t.code,{children:"e2e/detox/screens"})," and ",(0,s.jsx)(t.code,{children:"e2e/playwright/screens"})," folders."]})]})}function h(e={}){const{wrapper:t}={...(0,i.M)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},2172:(e,t,n)=>{n.d(t,{I:()=>a,M:()=>r});var s=n(1504);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);