"use strict";(self.webpackChunkignite_cookbook=self.webpackChunkignite_cookbook||[]).push([[656],{9044:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var s=t(7624),o=t(2172);const a={title:"PowerSync and Supabase for Local-First Data Management",description:"Enhance your app with PowerSync and Supabase for efficient data synchronization between your app's local database and backend",tags:["PowerSync","React Native","Backend","State management","Database","Data Synchronization","Offline Support"],last_update:{author:"Trevor Coleman"},publish_date:new Date("2024-03-22T00:00:00.000Z")},i="PowerSync and Supabase for Local-First Data Management",r={id:"recipes/LocalFirstDataWithPowerSync",title:"PowerSync and Supabase for Local-First Data Management",description:"Enhance your app with PowerSync and Supabase for efficient data synchronization between your app's local database and backend",source:"@site/docs/recipes/LocalFirstDataWithPowerSync.md",sourceDirName:"recipes",slug:"/recipes/LocalFirstDataWithPowerSync",permalink:"/docs/recipes/LocalFirstDataWithPowerSync",draft:!1,unlisted:!1,tags:[{label:"PowerSync",permalink:"/docs/tags/power-sync"},{label:"React Native",permalink:"/docs/tags/react-native"},{label:"Backend",permalink:"/docs/tags/backend"},{label:"State management",permalink:"/docs/tags/state-management"},{label:"Database",permalink:"/docs/tags/database"},{label:"Data Synchronization",permalink:"/docs/tags/data-synchronization"},{label:"Offline Support",permalink:"/docs/tags/offline-support"}],version:"current",lastUpdatedBy:"Trevor Coleman",lastUpdatedAt:1725905270,formattedLastUpdatedAt:"Sep 9, 2024",frontMatter:{title:"PowerSync and Supabase for Local-First Data Management",description:"Enhance your app with PowerSync and Supabase for efficient data synchronization between your app's local database and backend",tags:["PowerSync","React Native","Backend","State management","Database","Data Synchronization","Offline Support"],last_update:{author:"Trevor Coleman"},publish_date:"2024-03-22T00:00:00.000Z"},sidebar:"mainSidebar",previous:{title:"Generator for Component Tests",permalink:"/docs/recipes/GeneratorComponentTests"},next:{title:"Maestro Setup",permalink:"/docs/recipes/MaestroSetup"}},c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"What is PowerSync?",id:"what-is-powersync",level:3},{value:"Benefits of Using PowerSync",id:"benefits-of-using-powersync",level:3},{value:"Using Other Backends",id:"using-other-backends",level:3},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Installing SDK and Dependencies",id:"installing-sdk-and-dependencies",level:2},{value:"Install necessary dependencies for PowerSync.",id:"install-necessary-dependencies-for-powersync",level:3},{value:"Install necessary dependencies for Supabase",id:"install-necessary-dependencies-for-supabase",level:3},{value:"Metro Configuration",id:"metro-configuration",level:3},{value:"Authenticating with Supabase",id:"authenticating-with-supabase",level:2},{value:"Add Supabase Config Variables to <code>BaseConfig</code>",id:"add-supabase-config-variables-to-baseconfig",level:3},{value:"Initialize the Supabase Client",id:"initialize-the-supabase-client",level:3},{value:"Create <code>useAuth</code> Hook and <code>AuthContext</code>",id:"create-useauth-hook-and-authcontext",level:3},{value:"Provide Auth State to Your Application",id:"provide-auth-state-to-your-application",level:3},{value:"Create <code>AuthScreen</code> for signing in /  registering",id:"create-authscreen-for-signing-in---registering",level:3},{value:"Create the <code>SignOutButton</code> component",id:"create-the-signoutbutton-component",level:3},{value:"Add <code>SignOutButton</code> to <code>WelcomeScreen</code>",id:"add-signoutbutton-to-welcomescreen",level:3},{value:"Update the <code>AppNavigator</code>",id:"update-the-appnavigator",level:3},{value:"Checking In",id:"checking-in",level:3},{value:"Connecting PowerSync to Supabase",id:"connecting-powersync-to-supabase",level:2},{value:"Add your PowerSync URL to your app config",id:"add-your-powersync-url-to-your-app-config",level:3},{value:"Define Your Schema",id:"define-your-schema",level:3},{value:"Typescript Types",id:"typescript-types",level:4},{value:"The Schema for our Todo App",id:"the-schema-for-our-todo-app",level:4},{value:"Implement the SupabaseConnector",id:"implement-the-supabaseconnector",level:3},{value:"PowerSyncBackendConnector Interface",id:"powersyncbackendconnector-interface",level:4},{value:"Implement SupabaseConnector",id:"implement-supabaseconnector",level:4},{value:"Create the DatabaseContext",id:"create-the-databasecontext",level:3},{value:"Wrap the app in the DatabaseProvider",id:"wrap-the-app-in-the-databaseprovider",level:3},{value:"Managing Lists of Todos",id:"managing-lists-of-todos",level:2},{value:"The <code>useLists</code> Hook",id:"the-uselists-hook",level:3},{value:"useQuery",id:"usequery",level:4},{value:"PowerSync.execute()",id:"powersyncexecute",level:4},{value:"Disconnect PowerSync when we Sign Out",id:"disconnect-powersync-when-we-sign-out",level:4},{value:"install <code>expo-crypto</code> to generate UUIDs",id:"install-expo-crypto-to-generate-uuids",level:4},{value:"Implementing the <code>useLists</code> Hook",id:"implementing-the-uselists-hook",level:4},{value:"Create the Lists and AddLists Components",id:"create-the-lists-and-addlists-components",level:3},{value:"Add Lists to the Welcome Screen",id:"add-lists-to-the-welcome-screen",level:3},{value:"Display Todo Lists in <code>Lists</code>",id:"display-todo-lists-in-lists",level:3},{value:"Create Todo Lists with <code>AddList</code>",id:"create-todo-lists-with-addlist",level:3},{value:"Checking In",id:"checking-in-1",level:3},{value:"Viewing and Editing Individual TodoLists",id:"viewing-and-editing-individual-todolists",level:2},{value:"Create the TodoList Screen",id:"create-the-todolist-screen",level:3},{value:"Update the AppNavigator to include the <code>TodoList</code> screen",id:"update-the-appnavigator-to-include-the-todolist-screen",level:3},{value:"Update <code>Lists</code> so touching a list navigated to <code>TodoListScreen</code> and passes the <code>listId</code> param",id:"update-lists-so-touching-a-list-navigated-to-todolistscreen-and-passes-the-listid-param",level:3},{value:"Implement a <code>useList</code> hook to view and manage Todos for a List",id:"implement-a-uselist-hook-to-view-and-manage-todos-for-a-list",level:3},{value:"Implement <code>TodoListScreen</code> to Display and Edit Todos in a List",id:"implement-todolistscreen-to-display-and-edit-todos-in-a-list",level:3},{value:"Checking In",id:"checking-in-2",level:3},{value:"Congratulations!",id:"congratulations",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"powersync-and-supabase-for-local-first-data-management",children:"PowerSync and Supabase for Local-First Data Management"}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"This guide helps you integrate PowerSync with Supabase in an Ignite app for efficient local-first data management."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://www.powersync.com/",children:"PowerSync"})," allows your app to work smoothly offline while keeping the data in sync with your backend database."]}),"\n",(0,s.jsx)(n.h3,{id:"what-is-powersync",children:"What is PowerSync?"}),"\n",(0,s.jsx)(n.p,{children:"PowerSync is a service which synchronizes local data with your Postgres SQL back end. It lets your app work with a local copy of the users' data and automatically syncs changes to and from your backend."}),"\n",(0,s.jsx)(n.p,{children:"Because your application interacts with the data in a local instance of SQLite, it means you'll always have fast, responsive access -- no fetching, no spinners. It also means\nyour users will have a seamless, consistent experience even if they are offline."}),"\n",(0,s.jsx)(n.p,{children:"In the background, PowerSync queues any changes and syncs the local data with the server whenever an internet connection becomes available. That means the data stays up to date across all of their devices."}),"\n",(0,s.jsx)(n.h3,{id:"benefits-of-using-powersync",children:"Benefits of Using PowerSync"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handles Intermittent Network Connectivity"}),": PowerSync allows your app to remain operational even in areas with\nunreliable internet access. Users can continue their tasks without interruption, with automatic syncing when the\nconnection is restored."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enables Offline Operation"}),": With PowerSync, your application can fully function offline, allowing users to access\nand interact with their data regardless of their internet connection status."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Eliminates Loading Delays"}),": Leveraging local data minimizes the need for loading indicators, offering a smoother,\nfaster experience for the user."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Supports Multi-device Sync"}),": PowerSync ensures data consistency across all of a user's devices, enabling seamless\naccess and transition between different platforms.\nBy integrating PowerSync into your Ignite project, you provide a more reliable and user-friendly experience, ensuring\nyour application remains functional and responsive under various network conditions."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"using-other-backends",children:"Using Other Backends"}),"\n",(0,s.jsx)(n.p,{children:"While this recipe uses Supabase for the backend, PowerSync can connect to almost any Postgres SQL backend and the process will be largely identical for other types of Postgres backends."}),"\n",(0,s.jsxs)(n.p,{children:["The major difference is that when the time comes, you will need to implement a ",(0,s.jsx)(n.code,{children:"PowerSyncBackendConnector"})," for your database in place of the ",(0,s.jsx)(n.code,{children:"SupabaseConnector"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Check the ",(0,s.jsx)(n.a,{href:"https://docs.powersync.com/",children:"PowerSync documentation"})," for more information on connecting your database to PowerSync."]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(n.p,{children:"To complete this recipe you'll need:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["An Ignite app using ",(0,s.jsx)(n.code,{children:"Expo CNG"})," workflow"]})}),"\n",(0,s.jsx)(n.p,{children:"Create a new Ignite app using the Ignite CLI::"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npx ignite-cli@latest new PowerSyncIgnite --remove-demo --workflow=cng --yes\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["PowerSync requires native modules, so we need to use ",(0,s.jsx)(n.a,{href:"https://docs.expo.dev/workflow/continuous-native-generation/",children:"Expo with Continuous Native Generation (CNG)"}),"."]}),(0,s.jsxs)(n.p,{children:["If you are adding PowerSync to an app that currently uses Expo GO, you'll need to update your project to use either CNG or a ",(0,s.jsx)(n.a,{href:"https://docs.expo.dev/develop/development-builds/introduction/",children:"development build"}),"."]})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"A Supabase Project set up and connected to a PowerSync"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Follow the ",(0,s.jsx)(n.a,{href:"https://docs.powersync.com/integration-guides/supabase-+-powersync",children:"PowerSync + Supabase Integration Guide"})," to get this set up -- both PowerSync and Supabase have free tiers that you can use to get started."]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Configure or Disable Supabase Email Verification"})}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"By default, Supabase requires email verification for new users. This should be configured for any production apps."}),"\n",(0,s.jsxs)(n.li,{children:["For the purposes of this recipe, you can disable this in the Supabase dashboard under:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authentication"})," > ",(0,s.jsx)(n.strong,{children:"Providers"})," > ",(0,s.jsx)(n.strong,{children:"Email"})," > ",(0,s.jsx)(n.strong,{children:"Confirm Email"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"installing-sdk-and-dependencies",children:"Installing SDK and Dependencies"}),"\n",(0,s.jsx)(n.h3,{id:"install-necessary-dependencies-for-powersync",children:"Install necessary dependencies for PowerSync."}),"\n",(0,s.jsx)(n.p,{children:"First install the PowerSync SDK and its dependencies."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npx expo install \\\n  @powersync/react-native \\\n  @journeyapps/react-native-quick-sqlite \n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"These dependencies include native modules so you'll need to rebuild your app after installing."})}),"\n",(0,s.jsx)(n.h3,{id:"install-necessary-dependencies-for-supabase",children:"Install necessary dependencies for Supabase"}),"\n",(0,s.jsx)(n.p,{children:"First we need to install the Supabase SDK."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npx expo install @supabase/supabase-js\n"})}),"\n",(0,s.jsxs)(n.p,{children:["and we'll also need to install ",(0,s.jsx)(n.code,{children:"@react-native-async-storage/async-storage"})," for persisting the Supabase session."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npx expo install @react-native-async-storage/async-storage\n"})}),"\n",(0,s.jsx)(n.h3,{id:"metro-configuration",children:"Metro Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The default Metro configuration uses inline requires. The ",(0,s.jsx)(n.code,{children:"@powersync/react-native"})," package does not work well with inline requires. Update the Metro config to not use inline requires for the PowerSync SDK."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// `metro.config.js`:\n// Learn more https://docs.expo.io/guides/customizing-metro\nconst { getDefaultConfig } = require("expo/metro-config")\n\n/** @type {import(\'expo/metro-config\').MetroConfig} */\nconst config = getDefaultConfig(__dirname)\n\nconfig.transformer.getTransformOptions = async () => ({\n  transform: {\n    // Inline requires are very useful for deferring loading of large dependencies/components.\n    // For example, we use it in app.tsx to conditionally load Reactotron.\n    // However, this comes with some gotchas.\n    // Read more here: https://reactnative.dev/docs/optimizing-javascript-loading\n    // And here: https://github.com/expo/expo/issues/27279#issuecomment-1971610698\n    inlineRequires: {\n      blockList: {\n        [require.resolve("@powersync/react-native")]: true,\n\n        // require() calls anywhere else will be inlined, unless they\n        // match any entry nonInlinedRequires.\n      },\n    },\n  },\n})\n\n// This helps support certain popular third-party libraries\n// such as Firebase that use the extension cjs.\nconfig.resolver.sourceExts.push("cjs")\n\nmodule.exports = config\n\n'})}),"\n",(0,s.jsx)(n.h2,{id:"authenticating-with-supabase",children:"Authenticating with Supabase"}),"\n",(0,s.jsx)(n.p,{children:"PowerSync needs a valid session token to authenticate your Supabase users. In the next section we'll implement a basic authentication flow that will let us sign in and out of Supabase."}),"\n",(0,s.jsxs)(n.h3,{id:"add-supabase-config-variables-to-baseconfig",children:["Add Supabase Config Variables to ",(0,s.jsx)(n.code,{children:"BaseConfig"})]}),"\n",(0,s.jsxs)(n.p,{children:["First add your Supabase config to your app's configuration. In ignite apps, config is kept in ",(0,s.jsx)(n.code,{children:"app/config/config.base.ts"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"You'll need:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"supabaseUrl"}),": Found through your Supabase dashboard under: ",(0,s.jsx)(n.strong,{children:"Project Settings"})," > ",(0,s.jsx)(n.strong,{children:"API"})," > ",(0,s.jsx)(n.strong,{children:"Project URL"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"supabaseAnonKey"}),": Found through your Supabase dashboard under: ",(0,s.jsx)(n.strong,{children:"Project Settings"})," > ",(0,s.jsx)(n.strong,{children:"API"})," > ",(0,s.jsx)(n.strong,{children:"Project API\nkeys"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// `app/config/config.base.ts`:\n\n// update the interface to include the new properties\nexport interface ConfigBaseProps {\n  // Existing config properties\n\n  // success-line\n  supabaseUrl: string\n  // success-line\n  supabaseAnonKey: string\n}\n\n// Add the new properties to the config object\nconst BaseConfig: ConfigBaseProps = {\n  // Existing config values\n  // success-line\n  supabaseUrl: '<<YOUR_SUPABASE_URL>>',\n  // success-line\n  supabaseAnonKey: '<<YOUR_SUPABASE_ANON_KEY>>',\n}\n\nexport default BaseConfig;\n\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["If you have different configurations for different environments, you can add these properties to ",(0,s.jsx)(n.code,{children:"config.dev.ts"})," and ",(0,s.jsx)(n.code,{children:"config.prod.ts"})," as needed."]})}),"\n",(0,s.jsx)(n.h3,{id:"initialize-the-supabase-client",children:"Initialize the Supabase Client"}),"\n",(0,s.jsxs)(n.p,{children:["Create ",(0,s.jsx)(n.code,{children:"app/services/database/supabase.ts"})," and add the following code to initialize the Supabase client:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/services/database/supabase.ts\nimport AsyncStorage from '@react-native-async-storage/async-storage'\nimport { createClient } from \"@supabase/supabase-js\"\nimport Config from '../../config'\n\nexport const supabase = createClient(Config.supabaseUrl, Config.supabaseAnonKey, {\n  auth: {\n    persistSession: true, storage: AsyncStorage,\n  },\n})\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Persisting the Supabase Session",type:"info",children:[(0,s.jsxs)(n.p,{children:["Unlike web environments where ",(0,s.jsx)(n.code,{children:"localStorage"})," is available, in React Native Supabase requires us to provide a key-value store to hold the session token."]}),(0,s.jsxs)(n.p,{children:["We're using ",(0,s.jsx)(n.code,{children:"AsyncStorage"})," here for simplicity, but if you need more security, Supabase provides an example of encrypting the session token using ",(0,s.jsx)(n.code,{children:"expo-secure-storage"})," in their ",(0,s.jsx)(n.a,{href:"https://supabase.com/docs/guides/getting-started/tutorials/with-expo-react-native?auth-store=secure-store#initialize-a-react-native-app",children:"React Native Auth example"})]})]}),"\n",(0,s.jsxs)(n.h3,{id:"create-useauth-hook-and-authcontext",children:["Create ",(0,s.jsx)(n.code,{children:"useAuth"})," Hook and ",(0,s.jsx)(n.code,{children:"AuthContext"})]}),"\n",(0,s.jsx)(n.p,{children:"Next we'll create a hook and context to manage the authentication state and make it accessible to our components."}),"\n",(0,s.jsxs)(n.p,{children:["Create ",(0,s.jsx)(n.code,{children:"app/services/database/use-auth.tsx"})," and add the following code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/services/database/use-auth.tsx\nimport { User } from "@supabase/supabase-js"\nimport { supabase } from "app/services/database/supabase"\nimport React, { createContext, PropsWithChildren, useCallback, useContext, useMemo, useState } from "react"\n\ntype AuthContextType = {\n  signIn: (email: string, password: string) => void\n  signUp: (email: string, password: string) => void\n  signOut: () => Promise<void>\n  signedIn: boolean\n  loading: boolean\n  error: string\n  user: User | null\n}\n\n// We initialize the context with null to ensure that it is not used outside of the provider\nconst AuthContext = createContext<AuthContextType | null>(null)\n\n/**\n * AuthProvider manages the authentication state and provides the necessary methods to sign in, sign up and sign out.\n */\nexport const AuthProvider = ({ children }: PropsWithChildren<any>) => {\n  const [signedIn, setSignedIn] = useState(false)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState("")\n  const [user, setUser] = useState<User | null>(null)\n\n\n  // Sign in with provided email and password\n  const signIn = useCallback(async (email: string, password: string) => {\n    setLoading(true)\n    setError("")\n    setUser(null)\n    \n    try {\n      // get the session and user from supabase\n      const { \n        data: {session, user}, \n        error \n      } = await supabase.auth.signInWithPassword({ email, password })\n      \n      // if we have a session and user, sign them in\n      if (session && user) {\n        setSignedIn(true)\n        setUser(user)\n      // otherwise sign them out and set an error\n      } else {\n        throw new Error(error?.message);\n        setSignedIn(false)\n        setUser(null)\n      }\n    } catch (error: any) {\n      setError(error?.message ?? "Unknown error")\n      setSignedIn(false)\n      setUser(null)\n    } finally {\n      setLoading(false)\n    }\n  }, [\n    setSignedIn, setLoading, setError, setUser, supabase\n  ])\n\n  // Create a new account with provided email and password\n  const signUp = useCallback(async (email: string, password: string) => {\n    setLoading(true)\n    setError("")\n    setUser(null)\n    try {\n      const { data, error } = await supabase.auth.signUp({ email, password })\n      if (error) {\n        setSignedIn(false)\n        setError(error.message)\n      } else if (data.session) {\n        await supabase.auth.setSession(data.session)\n        setSignedIn(true)\n        setUser(data.user)\n      }\n    } catch (error: any) {\n      setUser(null)\n      setSignedIn(false)\n      setError(error?.message ?? "Unknown error")\n    } finally {\n      setLoading(false)\n    }\n  }, [\n    setSignedIn, setLoading, setError, setUser, supabase\n  ])\n\n  // Sign out the current user\n  const signOut = useCallback(async () => {\n    setLoading(true)\n    await supabase.auth.signOut()\n    setError("")\n    setSignedIn(false)\n    setLoading(false)\n    setUser(null)\n  }, [\n    setSignedIn, setLoading, setError, setUser, supabase\n  ])\n\n  // Always memoize context values as they can cause unnecessary re-renders if they aren\'t stable!\n  const value = useMemo(() => ({\n    signIn, signOut, signUp, signedIn, loading, error, user\n  }), [\n    signIn, signOut, signUp, signedIn, loading, error, user\n  ])\n  return <AuthContext.Provider value={ value }>{ children }</AuthContext.Provider>\n}\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext)\n\n  // It\'s a good idea to throw an error if the context is null, as it means the hook is being used outside of the provider\n  if (context === null) {\n    throw new Error(\'useAuthContext must be used within a AuthProvider\')\n  }\n  return context\n}\n\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["For more information on setting up authentication with Supabase (including setting up for OAuth providers like Github, Google and Facebook), refer to the ",(0,s.jsx)(n.a,{href:"https://supabase.com/docs/guides/auth",children:"Supabase Auth documentation"}),"."]})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"If authentication starts acting up, try refreshing your app from the Debug menu. Auth state is managed at the app level and that can cause issues with hot reloading."})}),"\n",(0,s.jsx)(n.h3,{id:"provide-auth-state-to-your-application",children:"Provide Auth State to Your Application"}),"\n",(0,s.jsxs)(n.p,{children:["Wrap your app with the ",(0,s.jsx)(n.code,{children:"AuthProvider"})," to provide the authentication state to your app:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/app.tsx\n// ...other imports\n// success-line\nimport { AuthProvider } from "app/services/database/use-auth"\n\n// ...\nfunction App(props: AppProps) {\n  // ...\n  return (\n    // success-line\n    <AuthProvider>\n      <SafeAreaProvider>\n        {/* ... */ }\n      </SafeAreaProvider>\n      // success-line\n    </AuthProvider>\n  )\n}\n\n\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"create-authscreen-for-signing-in---registering",children:["Create ",(0,s.jsx)(n.code,{children:"AuthScreen"})," for signing in /  registering"]}),"\n",(0,s.jsx)(n.p,{children:"Use the Ignite CLI to generate a new screen for signing in:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npx ignite-cli generate screen Auth\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.p,{children:"This will:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["create a new screen in ",(0,s.jsx)(n.code,{children:"app/screens/AuthScreen.tsx"}),","]}),"\n",(0,s.jsxs)(n.li,{children:["add that screen to the ",(0,s.jsx)(n.code,{children:"AppNavigator"})," in ",(0,s.jsx)(n.code,{children:"app/navigators/AppNavigator.tsx"}),", and"]}),"\n",(0,s.jsxs)(n.li,{children:["update the ",(0,s.jsx)(n.code,{children:"Params"})," and ",(0,s.jsx)(n.code,{children:"ScreenProps"})," types"]}),"\n"]})]}),"\n",(0,s.jsxs)(n.p,{children:["Then open ",(0,s.jsx)(n.code,{children:"app/screens/AuthScreen.tsx"})," and update the ",(0,s.jsx)(n.code,{children:"AuthScreen"})," component to use the ",(0,s.jsx)(n.code,{children:"useAuth"})," hook to sign in."]}),"\n",(0,s.jsxs)(n.p,{children:["When the user signs in successfully, the app will automatically navigate to the ",(0,s.jsx)(n.code,{children:"Welcome"})," screen."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/screens/AuthScreen.tsx\nimport { AppStackScreenProps } from "app/navigators"\nimport { Button, Screen, Text, TextField } from "app/components"\nimport { useAuth } from "app/services/database/use-auth"\nimport React, { useEffect, useState } from "react"\nimport { ActivityIndicator, Modal, TextStyle, View, ViewStyle } from "react-native"\nimport { colors, spacing } from "../theme"\n\ninterface AuthScreenProps extends AppStackScreenProps<"Auth"> {}\n\nexport const AuthScreen: React.FC<AuthScreenProps> = ({ navigation }) => {\n  const { signUp, signIn, loading, error, user } = useAuth()\n  const [email, setEmail] = useState("")\n  const [password, setPassword] = useState("")\n\n  const handleSignIn = async () => {\n    signIn(email, password)\n  }\n\n  const handleSignUp = async () => {\n    signUp(email, password)\n  }\n\n  useEffect(() => {\n    if (user) {\n      navigation.navigate("Welcome")\n    }\n  }, [user])\n\n  return (\n    <Screen style={ $container } safeAreaEdges={ ["top"] }>\n      <Text preset={ "subheading" }>PowerSync + Supabase</Text>\n      <Text preset={ "heading" }>Sign in or Create Account</Text>\n      <TextField\n        inputWrapperStyle={ $inputWrapper }\n        containerStyle={ $inputContainer }\n        label={ "Email" }\n        value={ email }\n        inputMode={ "email" }\n        onChangeText={ setEmail }\n        keyboardType="email-address"\n        autoCapitalize={ "none" }\n      />\n      <TextField\n        containerStyle={ $inputContainer }\n        inputWrapperStyle={ $inputWrapper }\n        label={ "Password" }\n        value={ password }\n        onChangeText={ setPassword }\n        secureTextEntry\n      />\n\n      <View style={ $buttonContainer }>\n        <Button\n          disabled={ loading }\n          text={ "Sign In" }\n          onPress={ handleSignIn }\n          style={ $button }\n          preset={ "reversed" }\n        />\n\n        <Button\n          disabled={ loading }\n          text={ "Register New Account" }\n          onPress={ handleSignUp }\n          style={ $button }\n        />\n      </View>\n      { error ? <Text style={ $error } text={ error }/> : null }\n      <Modal transparent visible={ loading }>\n        <View style={ $modalBackground }>\n          <ActivityIndicator size="large" color={ colors.palette.primary500 }/>\n        </View>\n      </Modal>\n    </Screen>\n  )\n}\n\nconst $container: ViewStyle = {\n  backgroundColor: colors.background,\n  flex: 1,\n  justifyContent: "center",\n  paddingHorizontal: spacing.lg,\n}\n\nconst $inputContainer: TextStyle = {\n  marginTop: spacing.md,\n}\n\nconst $inputWrapper: TextStyle = {\n  backgroundColor: colors.palette.neutral100,\n}\nconst $modalBackground: ViewStyle = {\n  alignItems: "center",\n  backgroundColor: "#00000040",\n  flex: 1,\n  flexDirection: "column",\n  justifyContent: "space-around",\n}\n\nconst $error: TextStyle = {\n  color: colors.error,\n  marginVertical: spacing.md,\n  textAlign: "center",\n  width: "100%",\n  fontSize: 20,\n}\n\nconst $buttonContainer: ViewStyle = {\n  display: "flex",\n  flexDirection: "column",\n  justifyContent: "space-between",\n  marginVertical: spacing.md,\n}\n\nconst $button: ViewStyle = {\n  marginTop: spacing.xs,\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"create-the-signoutbutton-component",children:["Create the ",(0,s.jsx)(n.code,{children:"SignOutButton"})," component"]}),"\n",(0,s.jsx)(n.p,{children:"First use the ignite CLI to generate a new screen for signing out:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npx ignite-cli generate component SignOutButton\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then, update the component to show a button that calls ",(0,s.jsx)(n.code,{children:"signOut"})," from our ",(0,s.jsx)(n.code,{children:"useAuth"})," when pressed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/components/SignOutButton.tsx\n\nimport { Button } from "app/components/Button"\nimport { useAuth } from "app/services/database/use-auth"\nimport * as React from "react"\nimport { StyleProp, View, ViewStyle } from "react-native"\nimport { observer } from "mobx-react-lite"\nimport { spacing } from "app/theme"\n\nexport interface SignOutButtonProps {\n  /**\n   * An optional style override useful for padding & margin.\n   */\n  style?: StyleProp<ViewStyle>\n}\n\n/**\n * Describe your component here\n */\nexport const SignOutButton = observer(function SignOutButton(props: SignOutButtonProps) {\n  const { style } = props\n  const $styles = [$container, style]\n\n  const { signOut } = useAuth()\n\n  const handleSignOut = async () => {\n    await signOut()\n  }\n\n  return (\n    <View style={ $styles }>\n      <Button text="Sign Out" onPress={ handleSignOut }/>\n    </View>\n  )\n})\n\nconst $container: ViewStyle = {\n  padding: spacing.md,\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"add-signoutbutton-to-welcomescreen",children:["Add ",(0,s.jsx)(n.code,{children:"SignOutButton"})," to ",(0,s.jsx)(n.code,{children:"WelcomeScreen"})]}),"\n",(0,s.jsxs)(n.p,{children:["Right now we just want to confirm that our authentication is working, so lets clear out the Welcome screen and add the ",(0,s.jsx)(n.code,{children:"SignOutButton"})," to it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/screens/WelcomeScreen.tsx\nimport { SignOutButton } from "app/components"\nimport { observer } from "mobx-react-lite"\nimport React, { FC } from "react"\nimport { ViewStyle } from "react-native"\nimport { SafeAreaView } from "react-native-safe-area-context"\nimport { colors } from "../theme"\n\ninterface WelcomeScreenProps\n  extends NativeStackScreenProps<SignedInNavigatorParamList, "Welcome"> {}\n\nexport const WelcomeScreen: FC<WelcomeScreenProps> = observer(function WelcomeScreen() {\n  return (\n    <SafeAreaView style={$container}>\n      <SignOutButton />\n    </SafeAreaView>\n  )\n})\n\nconst $container: ViewStyle = {\n  flex: 1,\n  backgroundColor: colors.palette.neutral300,\n  display: "flex",\n  justifyContent: "flex-start",\n  height: "100%",\n  flexDirection: "column",\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"update-the-appnavigator",children:["Update the ",(0,s.jsx)(n.code,{children:"AppNavigator"})]}),"\n",(0,s.jsx)(n.p,{children:"We don't want to allow users to navigate to the Welcome screen if they are not signed in."}),"\n",(0,s.jsxs)(n.p,{children:["We can ensure this by checking the user's authentication status in the ",(0,s.jsx)(n.code,{children:"AppNavigator"})," and only allowing them to access the ",(0,s.jsx)(n.code,{children:"Auth"})," screen if they are not signed in."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/navigators/AppNavigator.tsx\n\n// success-line\nimport { useAuth } from "app/services/database/use-auth"\n\n//...\n\nconst AppStack = observer(function AppStack() {\n  // Fetch the user from the auth context\n  // success-line\n  // success-line\n  const { signedIn } = useAuth()\n  return (\n    <Stack.Navigator\n      screenOptions={ { headerShown: false, navigationBarColor: colors.background } }\n    >\n      {/**\n       * by wrapping the Welcome screen in a conditional, we ensure that\n       * the user can only access it if they are signed in\n       */ }\n      // success-line\n      { signedIn\n        // success-line\n        ? <Stack.Screen name="Welcome" component={ Screens.WelcomeScreen }/>\n        // success-line\n        : null\n        // success-line\n      }\n      <Stack.Screen name="Auth" component={ Screens.AuthScreen }/>\n      {/* IGNITE_GENERATOR_ANCHOR_APP_STACK_SCREENS */ }\n    </Stack.Navigator>\n  )\n})\n\n// ...\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["For more information on Authentication flows with ",(0,s.jsx)(n.code,{children:"react-navigation"})," see their docs: ",(0,s.jsx)(n.a,{href:"https://reactnavigation.org/docs/auth-flow/",children:"https://reactnavigation.org/docs/auth-flow/"})]})}),"\n",(0,s.jsx)(n.h3,{id:"checking-in",children:"Checking In"}),"\n",(0,s.jsx)(n.p,{children:"At this point you should be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"sign in"})," and ",(0,s.jsx)(n.strong,{children:"sign out"})," of your app"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"sign up"})," for a new account."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If you are getting errors about an unverified email -- remember to disable email verification in the Supabase dashboard as described in the ",(0,s.jsx)(n.a,{href:"#prerequisites",children:"Prerequisites"})," section."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This is a good time to commit your changes!"})}),"\n",(0,s.jsx)(n.h2,{id:"connecting-powersync-to-supabase",children:"Connecting PowerSync to Supabase"}),"\n",(0,s.jsx)(n.p,{children:"Now that we have a valid Supabase session, we can connect to PowerSync and start syncing data between the local database and the backend."}),"\n",(0,s.jsx)(n.p,{children:"We'll need to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Add our PowerSync URL to the app configuration"}),"\n",(0,s.jsx)(n.li,{children:"Define our data schema, and"}),"\n",(0,s.jsx)(n.li,{children:"Connect to the database"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"add-your-powersync-url-to-your-app-config",children:"Add your PowerSync URL to your app config"}),"\n",(0,s.jsx)(n.p,{children:"Just like we did with supabase, add the PowerSync URL to your app's configuration."}),"\n",(0,s.jsxs)(n.p,{children:["Your PowerSync URL can be found in your ",(0,s.jsx)(n.strong,{children:"PowerSync dashboard"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Click on the ",(0,s.jsx)(n.strong,{children:"Edit Instance"})," button for your instance"]}),"\n",(0,s.jsxs)(n.li,{children:["Copy the ",(0,s.jsx)(n.strong,{children:"Instance URL"})," from the dialog that appears."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/config/config.base.ts:\n\n// update the interface to include the new properties\nexport interface ConfigBaseProps {\n  // Existing config properties\n  supabaseUrl: string\n  supabaseAnonKey: string\n  // success-line\n  powersyncUrl: string\n}\n\n// Add the new properties to the config object\nconst BaseConfig: ConfigBaseProps = {\n  // Existing config values\n  supabaseUrl: '<<YOUR_SUPABASE_URL>>',\n  supabaseAnonKey: '<<YOUR_SUPABASE_ANON_KEY>>',\n  // success-line\n  powersyncUrl: '<<YOUR_POWER_SYNC_URL>>',\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"define-your-schema",children:"Define Your Schema"}),"\n",(0,s.jsxs)(n.p,{children:["First we need to define the schema for our database and TypeScript types in ",(0,s.jsx)(n.code,{children:"app/services/database/schema.ts"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The Schema defines the data that PowerSync will sync between the local SQLite database and the backend."}),"\n",(0,s.jsxs)(n.p,{children:["From the ",(0,s.jsx)(n.a,{href:"https://docs.powersync.com/usage/installation/client-side-setup/define-your-schema#react-native-and-expo",children:"PowerSync docs"}),":"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["The types available are ",(0,s.jsx)(n.code,{children:"TEXT"}),", ",(0,s.jsx)(n.code,{children:"INTEGER"})," and ",(0,s.jsx)(n.code,{children:"REAL"}),". These should map directly to the values produced by the ",(0,s.jsx)(n.a,{href:"https://docs.powersync.com/usage/sync-rules",children:"Sync Rules"}),". If a value doesn't match, it is cast automatically."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"typescript-types",children:"Typescript Types"}),"\n",(0,s.jsx)(n.p,{children:"It's good to also define TypeScript types for your records, as this will help with type checking and autocompletion in your code."}),"\n",(0,s.jsx)(n.p,{children:"Keeping them with the schema will help keep your code organized and easy to maintain."}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["PowerSync supports ",(0,s.jsx)(n.a,{href:"https://kysely.dev/",children:"Kysely"}),", which enables automatically generation of typescript types for your database. See ",(0,s.jsx)(n.a,{href:"https://releases.powersync.com/announcements/kysely-orm-integration-for-react-native-and-js-web-beta-release",children:"this announcement"})," for more information on how to set that up for your project."]})}),"\n",(0,s.jsx)(n.h4,{id:"the-schema-for-our-todo-app",children:"The Schema for our Todo App"}),"\n",(0,s.jsx)(n.p,{children:"Here is the schema we'll be using for our todo app:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/services/database/schema.ts\nimport { column, Schema, TableV2 } from '@powersync/react-native';\n\nexport const LISTS_TABLE = 'lists';\nexport const TODOS_TABLE = 'todos';\n\nconst todos = new TableV2(\n  {\n    list_id: column.text,\n    created_at: column.text,\n    completed_at: column.text,\n    description: column.text,\n    created_by: column.text,\n    completed_by: column.text,\n    completed: column.integer\n  },\n  { indexes: { list: ['list_id'] } }\n);\n\nconst lists = new TableV2({\n  created_at: column.text,\n  name: column.text,\n  owner_id: column.text\n});\n\nexport const AppSchema = new Schema({\n  todos,\n  lists\n});\n\nexport type Database = (typeof AppSchema)['types'];\nexport type TodoRecord = Database['todos'];\n// OR:\n// export type Todo = RowType<typeof todos>;\n\nexport type ListRecord = Database['lists'];\n\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Automated Schema Generation",type:"tip",children:[(0,s.jsx)(n.p,{children:"PowerSync can generate a Javascript version of your schema for you."}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Right-click on your instance in the PowerSync dashboard"}),"\n",(0,s.jsx)(n.li,{children:'Select "Generate Client-Side Schema".'}),"\n"]}),(0,s.jsx)(n.p,{children:"This will generate a schema definition in javascript that will give you a good starting point for building the rest of your schema."})]}),"\n",(0,s.jsx)(n.h3,{id:"implement-the-supabaseconnector",children:"Implement the SupabaseConnector"}),"\n",(0,s.jsxs)(n.p,{children:["To tell PowerSync how to connect to the database we'll create a ",(0,s.jsx)(n.code,{children:"SupabaseConnector"}),", which implements the ",(0,s.jsx)(n.code,{children:"PowerSyncBackendConnector"})," interface with methods for fetching credentials and uploading data."]}),"\n",(0,s.jsx)(n.h4,{id:"powersyncbackendconnector-interface",children:"PowerSyncBackendConnector Interface"}),"\n",(0,s.jsxs)(n.p,{children:["The Supabase Connector needs to implement the ",(0,s.jsx)(n.code,{children:"PowerSyncBackendConnector"})," interface (",(0,s.jsx)(n.a,{href:"https://github.com/powersync-ja/powersync-js/blob/main/packages/common/src/client/connection/PowerSyncBackendConnector.ts",children:"declared here"}),"), ensuring it can seamlessly\ncommunicate with PowerSync for data synchronization."]}),"\n",(0,s.jsx)(n.p,{children:"The interface is straightforward and only requires two methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// from @journeyapps/powersync-sdk-common \nexport interface PowerSyncBackendConnector {\n  /** Allows the PowerSync client to retrieve an authentication token from your backend\n   * which is used to authenticate against the PowerSync service.\n   *\n   * This should always fetch a fresh set of credentials - don't use cached\n   * values.\n   *\n   * Return null if the user is not signed in. Throw an error if credentials\n   * cannot be fetched due to a network error or other temporary error.\n   *\n   * This token is kept for the duration of a sync connection.\n   */\n  fetchCredentials: () => Promise<PowerSyncCredentials | null>\n\n  /** Upload local changes to the app backend.\n   *\n   * Use {@link AbstractPowerSyncDatabase.getCrudBatch} to get a batch of changes to upload.\n   *\n   * Any thrown errors will result in a retry after the configured wait period (default: 5 seconds).\n   */\n  uploadData: (database: AbstractPowerSyncDatabase) => Promise<void>\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"implement-supabaseconnector",children:"Implement SupabaseConnector"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"app/services/database/supabase.ts"}),", we'll add the two methods, and then export an object that implements the ",(0,s.jsx)(n.code,{children:"PowerSyncBackendConnector"})," interface."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/services/database/supabase.ts\nimport {\n  AbstractPowerSyncDatabase,\n  CrudEntry,\n  PowerSyncBackendConnector,\n  UpdateType,\n  PowerSyncCredentials\n} from \"@powersync/react-native\"\nimport AsyncStorage from '@react-native-async-storage/async-storage'\nimport { createClient } from \"@supabase/supabase-js\"\nimport Config from \"../../config\"\n\nexport const supabase = createClient(Config.supabaseUrl, Config.supabaseAnonKey, {\n  auth: {\n    persistSession: true, storage: AsyncStorage,\n  },\n})\n\n\n// This function fetches the session token from Supabase, it should return null if the user is not signed in, and the session token if they are.\nasync function fetchCredentials(): Promise<PowerSyncCredentials | null> {\n  const { data: { session }, error } = await supabase.auth.getSession()\n\n  if (error) {\n    throw new Error(`Could not fetch Supabase credentials: ${ error }`)\n  }\n\n  if (!session) {\n    return null\n  }\n\n  return {\n    endpoint: Config.powersyncUrl,\n    token: session.access_token ?? \"\",\n    expiresAt: session.expires_at\n               ? new Date(session.expires_at * 1000)\n               : undefined\n  }\n}\n\n\n// Regexes for response codes indicating unrecoverable errors.\nconst FATAL_RESPONSE_CODES = [\n  /^22...$/, // Data Exception\n  /^23...$/, // Integrity Constraint Violation\n  /^42501$/, // INSUFFICIENT PRIVILEGE\n]\n\n// PowerSync will call this function to upload data to the backend\nconst uploadData: (database: AbstractPowerSyncDatabase) => Promise<void> = async (database) => {\n  const transaction = await database.getNextCrudTransaction()\n\n  if (!transaction) {\n    return\n  }\n\n\n  let lastOp: CrudEntry | null = null\n  try {\n    // Note: If transactional consistency is important, use database functions\n    // or edge functions to process the entire transaction in a single call.\n    for (const op of transaction.crud) {\n      lastOp = op\n      const table = supabase.from(op.table)\n      let result: any = null\n      switch (op.op) {\n        case UpdateType.PUT:\n          // eslint-disable-next-line no-case-declarations\n          const record = { ...op.opData, id: op.id }\n          result = await table.upsert(record)\n          break\n        case UpdateType.PATCH:\n          result = await table.update(op.opData).eq('id', op.id)\n          break\n        case UpdateType.DELETE:\n          result = await table.delete().eq('id', op.id)\n          break\n      }\n\n      if (result?.error) {\n        throw new Error(`Could not ${ op.op } data to Supabase error: ${ JSON.stringify(result) }`)\n      }\n    }\n\n    await transaction.complete()\n  } catch (ex: any) {\n    console.debug(ex)\n    if (typeof ex.code === 'string' && FATAL_RESPONSE_CODES.some((regex) => regex.test(ex.code))) {\n      /**\n       * Instead of blocking the queue with these errors,\n       * discard the (rest of the) transaction.\n       *\n       * Note that these errors typically indicate a bug in the application.\n       * If protecting against data loss is important, save the failing records\n       * elsewhere instead of discarding, and/or notify the user.\n       */\n      console.error(`Data upload error - discarding ${ lastOp }`, ex)\n      await transaction.complete()\n    } else {\n      // Error may be retryable - e.g. network error or temporary server error.\n      // Throwing an error here causes this call to be retried after a delay.\n      throw ex\n    }\n  }\n}\n\nexport const supabaseConnector: PowerSyncBackendConnector = {\n  fetchCredentials, uploadData,\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"create-the-databasecontext",children:"Create the DatabaseContext"}),"\n",(0,s.jsx)(n.p,{children:"We need a single point of connection to the PowerSync instance that we can interact with throughout the app."}),"\n",(0,s.jsxs)(n.p,{children:["To achieve this we create a ",(0,s.jsx)(n.code,{children:"Database"})," singleton and provide a stable reference to that instance through our ",(0,s.jsx)(n.code,{children:"DatabaseContext"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"We'll check if the user is signed in or not before we initialize the database, as we need a valid session token to connect to the backend."}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"DatabaseProvider"})," component wraps its children in both the ",(0,s.jsx)(n.code,{children:"DatabaseContext.Provider"}),", and also the ",(0,s.jsx)(n.code,{children:"PowerSyncContext.Provider"})," provided by the PowerSync SDK."]}),(0,s.jsxs)(n.p,{children:["This is necessary because the hooks from the PowerSync SDK require the ",(0,s.jsx)(n.code,{children:"PowerSyncContext"})," to be present in the component tree, but we'll still need the DatabaseContext to get access to the powersync instance directly."]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/services/database/database.tsx\nimport { SupabaseClient } from "@supabase/supabase-js"\nimport { useAuth } from "./use-auth"\nimport React, { PropsWithChildren, useEffect } from "react"\nimport {\n  AbstractPowerSyncDatabase,\n  PowerSyncContext,\n  PowerSyncDatabase,\n} from "@powersync/react-native"\nimport { supabase, supabaseConnector } from "./supabase" // Adjust the path as needed\nimport { AppSchema } from "./schema" // Adjust the path as needed\n\nexport class Database {\n  // We expose the PowerSync and Supabase instances for easy access elsewhere in the app\n  powersync: AbstractPowerSyncDatabase\n  supabase: SupabaseClient = supabase\n\n  /**\n   * Initialize the Database class with a new PowerSync instance\n   */\n  constructor() {\n    this.powersync = new PowerSyncDatabase({\n      database: {\n        dbFilename: "sqlite.db"\n      },\n      schema: AppSchema\n    })\n  }\n\n  /**\n   * Initialize the PowerSync instance and connect it to the Supabase backend.\n   * This will call `fetchCredentials` on the Supabase connector to get the session token.\n   * So if your database requires authentication, the user will need to be signed in before this is\n   * called.\n   */\n  async init() {\n    await this.powersync.init()\n    await this.powersync.connect(supabaseConnector)\n  }\n\n  async disconnect() {\n    await this.powersync.disconnectAndClear()\n  }\n}\n\nconst database = new Database()\n\n// A context to provide our singleton to the rest of the app\nconst DatabaseContext = React.createContext<Database | null>(null)\n\nexport const useDatabase = () => {\n  const context: Database | null = React.useContext(DatabaseContext)\n  if (!context) {\n    throw new Error("useDatabase must be used within a DatabaseProvider")\n  }\n\n  return context\n}\n\n// Finally, we create a provider component that initializes the database and provides it to the app\nexport function DatabaseProvider<T>({ children }: PropsWithChildren<T>) {\n  const { user } = useAuth()\n  useEffect(() => {\n    if (user) {\n      database.init().catch(console.error)\n    }\n  }, [database, user])\n  return (\n    <DatabaseContext.Provider value={ database }>\n      <PowerSyncContext.Provider value={ database.powersync }>\n        { children }\n      </PowerSyncContext.Provider>\n    </DatabaseContext.Provider>\n  )\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"wrap-the-app-in-the-databaseprovider",children:"Wrap the app in the DatabaseProvider"}),"\n",(0,s.jsxs)(n.p,{children:["Now that we have our ",(0,s.jsx)(n.code,{children:"DatabaseProvider"})," set up, we can wrap our app in it to provide the database instance to the rest of the app."]}),"\n",(0,s.jsxs)(n.p,{children:["Remember that the DatabaseProvider needs access to the users authentication state, so it should be wrapped in the ",(0,s.jsx)(n.code,{children:"AuthProvider"})," we created earlier."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/app.tsx\n\n\n//... other imports\n// success-line\n// Import the provider\n// success-line\nimport { DatabaseProvider } from "app/services/database/database"\n\n// ...\n\nfunction App(props: AppProps) {\n  // ...\n  return (\n    <AuthProvider>\n      // success-line\n      {/* Add the Database Provider inside the AuthProvider */ }\n      // success-line\n      <DatabaseProvider>\n        <SafeAreaProvider initialMetrics={ initialWindowMetrics }>\n          // ...\n        </SafeAreaProvider>\n        // success-line\n      </DatabaseProvider>\n    </AuthProvider>\n  )\n}\n\nexport default App\n\nconst $container: ViewStyle = {\n  flex: 1,\n}\n\n'})}),"\n",(0,s.jsx)(n.h2,{id:"managing-lists-of-todos",children:"Managing Lists of Todos"}),"\n",(0,s.jsx)(n.p,{children:"In our app we'll want the ability to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"fetch the list of all the todo lists from the database"}),"\n",(0,s.jsx)(n.li,{children:"add a new todo list"}),"\n",(0,s.jsx)(n.li,{children:"delete a todo list"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To manage this we'll create the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["a ",(0,s.jsx)(n.code,{children:"useLists"})," hook to encapsulate the logic for fetching and managing the lists"]}),"\n",(0,s.jsxs)(n.li,{children:["a ",(0,s.jsx)(n.code,{children:"Lists"})," component to display the lists"]}),"\n",(0,s.jsxs)(n.li,{children:["an ",(0,s.jsx)(n.code,{children:"AddList"})," component with a form to add a new list"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"the-uselists-hook",children:["The ",(0,s.jsx)(n.code,{children:"useLists"})," Hook"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useLists"})," hook will encapsulate the logic for fetching and managing the lists."]}),"\n",(0,s.jsx)(n.p,{children:"It will use:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useQuery"})," to fetch the lists from the database and watch for changes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PowerSync.execute"})," to create and delete lists"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"usequery",children:"useQuery"}),"\n",(0,s.jsx)(n.p,{children:"This hook is used to fetch data from the database and watch for changes. It will automatically re-fetch the data when the database changes."}),"\n",(0,s.jsx)(n.p,{children:"We'll implement our own in a second, but Here's an example of what that looks like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const { data: lists } = useQuery<ListItemRecord>(`\n    SELECT ${ LISTS_TABLE }.*,\n         COUNT(${ TODOS_TABLE }.id) AS total_tasks,\n         SUM(CASE WHEN ${ TODOS_TABLE }.completed = true THEN 1 ELSE 0 END) AS completed_tasks\n    FROM ${ LISTS_TABLE }\n         LEFT JOIN ${ TODOS_TABLE } ON ${ LISTS_TABLE }.id = ${ TODOS_TABLE }.list_id\n    GROUP BY ${ LISTS_TABLE }.id;\n  `);\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can write complex queries to fetch data from the database, and the hook will automatically re-fetch the data when the database changes."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["This hook needs to be inside a ",(0,s.jsx)(n.code,{children:"PowerSyncContext.Provider"})," (or our ",(0,s.jsx)(n.code,{children:"DatabaseProvider"}),") to work."]})}),"\n",(0,s.jsx)(n.h4,{id:"powersyncexecute",children:"PowerSync.execute()"}),"\n",(0,s.jsx)(n.p,{children:"This method is used to execute SQL queries against the database. We'll be using it here to create and delete lists."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const deleteList = useCallback(async (id: string) => {\n  console.log('Deleting list', id)\n  return powersync.execute(`DELETE FROM ${ LIST_TABLE } WHERE id = ?`, [id])\n}, [powersync])\n"})}),"\n",(0,s.jsx)(n.h4,{id:"disconnect-powersync-when-we-sign-out",children:"Disconnect PowerSync when we Sign Out"}),"\n",(0,s.jsx)(n.p,{children:"When we sign out, we should disconnect the PowerSync instance from the backend to prevent any further data synchronization,\nand wipe the local database to ensure that no data is left behind."}),"\n",(0,s.jsxs)(n.p,{children:["To do this we'll update our ",(0,s.jsx)(n.code,{children:"SignOutButton"})," to call ",(0,s.jsx)(n.code,{children:"powersync.disconnectAndClear()"})," before we sign out of supabase."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/components/SignOutButton.tsx\n\n//...other imports\nimport { useDatabase } from "app/services/database/database"\n\n// ...\nexport const SignOutButton = observer(function SignOutButton(props: SignOutButtonProps) {\n  // ...\n\n  const { signOut } = useAuth()\n  // success-line\n  const { powersync } = useDatabase()\n\n  // success-line\n  const handleSignOut = async () => {  // make this async\n    // success-line\n    await powersync.disconnectAndClear()\n    await signOut()\n  }\n\n  return (\n    <View style={ $styles }>\n      <Button text="Sign Out" onPress={ handleSignOut }/>\n    </View>\n  )\n})\n\n'})}),"\n",(0,s.jsxs)(n.h4,{id:"install-expo-crypto-to-generate-uuids",children:["install ",(0,s.jsx)(n.code,{children:"expo-crypto"})," to generate UUIDs"]}),"\n",(0,s.jsx)(n.p,{children:"Because PowerSync data is local-first, we can't rely on the database to generate auto-incrementing unique ids for us."}),"\n",(0,s.jsx)(n.p,{children:"When we're offline, the server won't know how many items we've creating, or how many other devices are creating items."}),"\n",(0,s.jsx)(n.p,{children:"So in this situation, the app needs to be responsible for generating unique ids for items locally."}),"\n",(0,s.jsxs)(n.p,{children:["We'll use the ",(0,s.jsx)(n.code,{children:"uuid()"})," SQLite method for this. It generates UUIDs using cryptographically secure\nrandom values. This provides extra security and ensures that the generated UUIDs are unique."]}),"\n",(0,s.jsxs)(n.h4,{id:"implementing-the-uselists-hook",children:["Implementing the ",(0,s.jsx)(n.code,{children:"useLists"})," Hook"]}),"\n",(0,s.jsxs)(n.p,{children:["Now that we can generate random IDs, we can implement the ",(0,s.jsx)(n.code,{children:"useLists"})," hook:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// app/services/database/use-lists.ts\nimport { useQuery } from "@powersync/react-native"\nimport { useAuth } from "app/services/database/use-auth"\nimport { useCallback } from "react"\nimport { useDatabase } from "app/services/database/database"\nimport { LISTS_TABLE, ListRecord, TODOS_TABLE } from "app/services/database/schema"\n\n// Extend the base type with the calculated fields from our query  \nexport type ListItemRecord = ListRecord & { total_tasks: number; completed_tasks: number }\n\nexport const useLists = () => {\n  // Get the current user from the auth context \n  const { user } = useAuth()\n  // Get the database instance from the context\n  const { powersync } = useDatabase()\n\n  // List fetching logic here. You can modify it as per your needs.\n  const { data: lists } = useQuery<ListItemRecord>(`\n      SELECT ${ LISTS_TABLE }.*,\n             COUNT(${ TODOS_TABLE }.id) AS total_tasks,\n             SUM(CASE WHEN ${ TODOS_TABLE }.completed = true THEN 1 ELSE 0 END) as completed_tasks\n      FROM ${ LISTS_TABLE }\n               LEFT JOIN ${ TODOS_TABLE } ON ${ LISTS_TABLE }.id = ${ TODOS_TABLE }.list_id\n      GROUP BY ${ LISTS_TABLE }.id\n  `)\n\n\n  const createList = useCallback(async (name: string) => {\n\n    if (!user) {throw new Error("Can\'t add list -- user is undefined")}\n\n    return powersync.execute(\n      `\n          INSERT INTO ${ LISTS_TABLE }\n              (id, name, created_at, owner_id)\n          VALUES (uuid(), ?, ?, ?)`,\n      [name, new Date().toISOString(), user?.id],\n    )\n  }, [user, powersync])\n\n  const deleteList = useCallback(async (id: string) => {\n    console.log(\'Deleting list\', id)\n    return powersync.execute(`DELETE\n                             FROM ${ LISTS_TABLE }\n                             WHERE id = ?`, [id])\n  }, [powersync])\n\n  return { lists, createList, deleteList }\n}\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"create-the-lists-and-addlists-components",children:"Create the Lists and AddLists Components"}),"\n",(0,s.jsx)(n.p,{children:"We're going to need several components to view and manage our todo lists:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AddList"})," - displays form to add a new list"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Lists"})," - displays the list of todo lists and allows the user to delete them"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let start by creating the components using the ignite CLI."}),"\n",(0,s.jsxs)(n.p,{children:["First create the ",(0,s.jsx)(n.code,{children:"AddList"})," and ",(0,s.jsx)(n.code,{children:"Lists"})," components:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npx ignite-cli generate component AddList\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npx ignite-cli generate component Lists\n"})}),"\n",(0,s.jsx)(n.h3,{id:"add-lists-to-the-welcome-screen",children:"Add Lists to the Welcome Screen"}),"\n",(0,s.jsxs)(n.p,{children:["Add the ",(0,s.jsx)(n.code,{children:"Lists"})," component to the ",(0,s.jsx)(n.code,{children:"WelcomeScreen"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/screens/WelcomeScreen.tsx\nimport { NativeStackScreenProps } from "@react-navigation/native-stack"\nimport { Lists, SignOutButton } from "app/components"\nimport { observer } from "mobx-react-lite"\nimport React, { FC } from "react"\nimport { ViewStyle } from "react-native"\nimport { SafeAreaView } from "react-native-safe-area-context"\nimport { SignedInNavigatorParamList } from "../navigators"\nimport { colors } from "../theme"\n\ninterface WelcomeScreenProps\n  extends NativeStackScreenProps<SignedInNavigatorParamList, "Welcome"> {}\n\nexport const WelcomeScreen: FC<WelcomeScreenProps> = observer(function WelcomeScreen() {\n  return (\n    <SafeAreaView style={ $container }>\n      // success-line\n      <Lists/>\n      <SignOutButton/>\n    </SafeAreaView>\n  )\n})\n\nconst $container: ViewStyle = {\n  flex: 1,\n  backgroundColor: colors.palette.neutral300,\n  display: "flex",\n  justifyContent: "flex-start",\n  height: "100%",\n  flexDirection: "column",\n}\n\n\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"display-todo-lists-in-lists",children:["Display Todo Lists in ",(0,s.jsx)(n.code,{children:"Lists"})]}),"\n",(0,s.jsxs)(n.p,{children:["Now we can use our ",(0,s.jsx)(n.code,{children:"useLists"})," hook in ",(0,s.jsx)(n.code,{children:"app/components/Lists.tsx"})," to display a list of our todo lists -- we don't have any in our database yet, but we'll add some soon!"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/components/Lists.tsx\nimport { NavigationProp, useNavigation } from "@react-navigation/native"\nimport { AddList, Icon, ListItem, Text } from "app/components"\nimport { AppStackParamList } from "app/navigators"\nimport { ListItemRecord, useLists } from "app/services/database/use-lists"\nimport React, { useCallback } from "react"\nimport { FlatList, TextStyle, View, ViewStyle } from "react-native"\nimport { colors, spacing } from "../theme"\n\nexport function Lists() {\n  \n  // use our hook to fetch the lists\n  const { lists, deleteList } = useLists()\n  const navigation = useNavigation<NavigationProp<AppStackParamList>>()\n\n  // This function tells FlatList how to render each item\n  const renderItem = useCallback(({ item }: { item: ListItemRecord }) => {\n    return (\n      <ListItem\n        textStyle={ $listItemText }\n        onPress={ () => {\n          // Eventually  this si where we\'ll navigate to the todo, but for now we\'ll just log the list name\n          console.log(\'Pressed: \', item.name)\n        } }\n        text={ `${ item.name }` }\n        RightComponent={\n          <View style={ $deleteListIcon }>\n            {/* Let users delete lists */}\n            <Icon icon={ "x" } onPress={ () => deleteList(item.id) }/>\n          </View>\n        }\n      />\n    )\n  }, [])\n\n  return (\n    <View style={ $container }>\n      <Text preset={ "heading" }>Lists</Text>\n      <View style={ $card }>\n        <AddList/>\n      </View>\n      <View style={ [$list, $card] }>\n        <Text preset={ "subheading" }>Your Lists</Text>\n        <FlatList\n          style={ $listContainer }\n          // pass in our lists\n          data={ lists }\n          // pass in our renderItem function\n          renderItem={ renderItem }\n          keyExtractor={ (item) => item.id }\n          ItemSeparatorComponent={ () => <View style={ $separator }/> }\n          // show a message if the list is empty\n          ListEmptyComponent={ <Text style={ $emptyList }>No lists found</Text> }\n        />\n      </View>\n    </View>\n  )\n}\n\n// STYLES\nconst $separator: ViewStyle = { height: 1, backgroundColor: colors.border }\nconst $emptyList: TextStyle = {\n  textAlign: "center",\n  color: colors.textDim,\n  opacity: 0.5,\n  padding: spacing.lg,\n}\nconst $card: ViewStyle = {\n  shadowColor: colors.palette.neutral800,\n  shadowOffset: { width: 0, height: 1 },\n  shadowRadius: 2,\n  shadowOpacity: 0.35,\n  borderRadius: 8,\n}\nconst $listContainer: ViewStyle = {\n  backgroundColor: colors.palette.neutral100,\n  paddingHorizontal: spacing.md,\n  height: "100%",\n  borderColor: colors.border,\n  borderWidth: 1,\n}\nconst $list: ViewStyle = {\n  flex: 1,\n  marginVertical: spacing.md,\n  backgroundColor: colors.palette.neutral200,\n  padding: spacing.md,\n}\nconst $container: ViewStyle = {\n  flex: 1,\n  display: "flex",\n  flexGrow: 1,\n  padding: spacing.md,\n}\nconst $listItemText: TextStyle = {\n  height: 44,\n  width: 44,\n}\nconst $deleteListIcon: ViewStyle = {\n  display: "flex",\n  justifyContent: "center",\n  alignItems: "center",\n  height: 44,\n  marginVertical: spacing.xxs,\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"create-todo-lists-with-addlist",children:["Create Todo Lists with ",(0,s.jsx)(n.code,{children:"AddList"})]}),"\n",(0,s.jsxs)(n.p,{children:["Open ",(0,s.jsx)(n.code,{children:"app/components/AddList.tsx"})," and update the ",(0,s.jsx)(n.code,{children:"AddList"})," component to display a simple form to add a new list."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/components/AddList.tsx\nimport { Button, Text, TextField } from "app/components"\nimport { useLists } from "app/services/database/use-lists"\nimport { colors, spacing } from "app/theme"\nimport { observer } from "mobx-react-lite"\nimport React from "react"\nimport { Keyboard, TextStyle, View, ViewStyle } from "react-native"\n\n/**\n * Display a form to add a new list\n */\nexport const AddList = observer(function AddList() {\n  const [newListName, setNewListName] = React.useState("")\n  const [error, setError] = React.useState<string | null>(null)\n\n  // we use the function from  our hook to create a new list\n  const { createList } = useLists()\n\n  const handleAddList = React.useCallback(async () => {\n    if (!newListName) {\n      Keyboard.dismiss()\n      return\n    }\n    try {\n      await createList(newListName)\n      setNewListName("")\n    } catch (e: any) {\n      setError(`Failed to create list: ${ e?.message ?? "unknown error" }`)\n    } finally {\n      Keyboard.dismiss()\n    }\n  }, [createList, newListName])\n\n  return (\n    <View style={ $container }>\n      <Text preset={ "subheading" }>Add a List</Text>\n      <View style={ $form }>\n        <TextField\n          placeholder="Enter a list name"\n          containerStyle={ $textField }\n          inputWrapperStyle={ $textInput }\n          onChangeText={ setNewListName }\n          value={ newListName }\n          onSubmitEditing={ handleAddList }\n        />\n        <Button text="Add List" style={ $button } onPress={ handleAddList }/>\n      </View>\n      { error && <Text style={ $error }>{ error }</Text> }\n    </View>\n  )\n})\n\nconst $container: ViewStyle = {\n  padding: spacing.md,\n  backgroundColor: colors.palette.neutral200,\n}\n\nconst $form: ViewStyle = {\n  display: "flex",\n  flexDirection: "row",\n  alignItems: "center",\n}\n\nconst $textField: ViewStyle = {\n  flex: 1,\n}\n\nconst $textInput: ViewStyle = {\n  backgroundColor: colors.palette.neutral100,\n}\n\nconst $button: ViewStyle = {\n  marginHorizontal: spacing.xs,\n  padding: 0,\n  paddingHorizontal: spacing.xs,\n  paddingVertical: 0,\n  minHeight: 44,\n}\n\nconst $error: TextStyle = {\n  color: colors.error,\n  marginTop: spacing.sm,\n}\n\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"checking-in-1",children:"Checking In"}),"\n",(0,s.jsx)(n.p,{children:"By this point you should be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"add new Todo lists,"}),"\n",(0,s.jsx)(n.li,{children:"see a list of all the Todo lists,"}),"\n",(0,s.jsx)(n.li,{children:"delete Todo lists from the list of lists."}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This is a good time to commit your changes!"})}),"\n",(0,s.jsx)(n.h2,{id:"viewing-and-editing-individual-todolists",children:"Viewing and Editing Individual TodoLists"}),"\n",(0,s.jsx)(n.p,{children:"To view and edit todos inside a list, we'll want to create a new Screen, and add it to the navigator so we can navigate to it."}),"\n",(0,s.jsx)(n.h3,{id:"create-the-todolist-screen",children:"Create the TodoList Screen"}),"\n",(0,s.jsxs)(n.p,{children:["First lets create a new screen called ",(0,s.jsx)(n.code,{children:"TodoList"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npx ignite-cli generate screen TodoList\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will eventually display the todos for a list. For now we'll just leave it as-is."}),"\n",(0,s.jsxs)(n.h3,{id:"update-the-appnavigator-to-include-the-todolist-screen",children:["Update the AppNavigator to include the ",(0,s.jsx)(n.code,{children:"TodoList"})," screen"]}),"\n",(0,s.jsxs)(n.p,{children:["Open ",(0,s.jsx)(n.code,{children:"app/navigators/SignedInNavigator.tsx"})," and add the ",(0,s.jsx)(n.code,{children:"TodoList"})," screen to the navigator."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Find the ",(0,s.jsx)(n.code,{children:"TodoList"})," screen in ",(0,s.jsx)(n.code,{children:"AppStackParamList"}),", and update it to take a ",(0,s.jsx)(n.code,{children:"listId"})," parameter."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// app/navigators/AppNavigator.tsx\nexport type AppStackParamList = {\n  Welcome: undefined\n  Auth: undefined\n  // success-line\n  TodoList: { listId: string }  // add this line\n  // IGNITE_GENERATOR_ANCHOR_APP_STACK_PARAM_LIST\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Wrap ",(0,s.jsx)(n.code,{children:"WelcomeScreen"})," in a fragment (",(0,s.jsx)(n.code,{children:"<>...</>"}),") and move the ",(0,s.jsx)(n.code,{children:"TodoList"})," screen inside the fragment."]}),"\n",(0,s.jsx)(n.p,{children:"Because the fragment is wrapped in the conditional, it will only be rendered if the user is signed in."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// ...\n\nconst AppStack = observer(function AppStack() {\n  // Fetch the user from the auth context\n  const { signedIn } = useAuth()\n  return (\n    <Stack.Navigator screenOptions={ { headerShown: false, navigationBarColor: colors.background } }>\n      <Stack.Screen name={ "Auth" } component={ AuthScreen }/>\n      // success-line\n      { signedIn ? (\n        // success-line\n        <>\n          // success-line\n          <Stack.Screen name="Welcome" component={ Screens.WelcomeScreen }/>\n          // success-line\n          <Stack.Screen name="TodoList" component={ Screens.TodoListScreen }/>\n          // success-line\n        </>\n        // success-line\n      ) : null }\n      {/* IGNITE_GENERATOR_ANCHOR_APP_STACK_SCREENS */ }\n    </Stack.Navigator>\n  )\n})\n\nexport const AppNavigator = observer(function AppNavigator(props: NavigationProps) {\n  // ...   \n})\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Open ",(0,s.jsx)(n.code,{children:"app/screens/TodoListScreen.tsx"})," and update the screen to receive the ",(0,s.jsx)(n.code,{children:"listId"})," parameter -- for now we'll just display it to make sure we got it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/screens/TodoListScreen.tsx\n// ...\n\nexport const TodoListScreen: FC<TodoListScreenProps> = function TodoListScreen({\n  navigation,\n  // success-line\n  // We get the listId from the route params\n  // success-line\n  route: { params: {listId} }\n}) {\n  return (\n    <Screen style={ $root } preset="scroll" safeAreaEdges={ ["top"] }>\n      // success-line\n      <Pressable onPress={ () => navigation.goBack() }>\n        <Icon icon={ "back" } size={ 50 }/>\n      </Pressable>\n      // success-line\n      <Text preset={ "heading" } text={ listId }/>\n    </Screen>\n  )\n}\n\nconst $root: ViewStyle = {\n  flex: 1,\n}\n\nconst $backButton: ViewStyle = {\n  height: 44,\n}\n\n\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"update-lists-so-touching-a-list-navigated-to-todolistscreen-and-passes-the-listid-param",children:["Update ",(0,s.jsx)(n.code,{children:"Lists"})," so touching a list navigated to ",(0,s.jsx)(n.code,{children:"TodoListScreen"})," and passes the ",(0,s.jsx)(n.code,{children:"listId"})," param"]}),"\n",(0,s.jsxs)(n.p,{children:["Now we can update the ",(0,s.jsx)(n.code,{children:"Lists"})," component to navigate to the ",(0,s.jsx)(n.code,{children:"TodoList"})," screen when a list is pressed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/components/Lists.tsx\n\n// ... other imports\nimport { NavigationProp, useNavigation } from "@react-navigation/native"\nimport { AppStackParamList } from "app/navigators"\n\nexport function Lists() {\n\n  const { lists, deleteList } = useLists()\n  // We use the root param list, because this component might be reusing in other screens/navigators\n  // success-line\n  const navigation = useNavigation<NavigationProp<AppStackParamList>>()\n\n  const renderItem = useCallback(({ item }: { item: ListItemRecord }) => {\n    return <ListItem\n      // ... other props\n      // Navigate to the TodoList screen, passing the `listId` as a parameter\n      onPress={ () => {\n        // success-line\n        navigation.navigate("TodoList", { listId: item.id })\n      } }\n    />\n  }, [])\n\n  return (\n    //... component body\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"implement-a-uselist-hook-to-view-and-manage-todos-for-a-list",children:["Implement a ",(0,s.jsx)(n.code,{children:"useList"})," hook to view and manage Todos for a List"]}),"\n",(0,s.jsxs)(n.p,{children:["Now that we can navigate to the ",(0,s.jsx)(n.code,{children:"TodoList"})," screen, we can start fetching and managing the todos for a list."]}),"\n",(0,s.jsx)(n.p,{children:"Once again we'll create a hook to gather together the methods we'll likely use together."}),"\n",(0,s.jsxs)(n.p,{children:["The hook will take a ",(0,s.jsx)(n.code,{children:"listId"})," as a parameter, and return the list, the todos for that list, and functions to add and remove todos."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["We are using ",(0,s.jsx)(n.code,{children:"usePowerSyncQuery"})," to fetch the list and ",(0,s.jsx)(n.code,{children:"usePowerSyncWatchedQuery"})," to fetch the todos, because the list itself won't change often, so we only need to watch the todos for changes."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/services/database/use-list.ts\n\nimport { useQuery } from "@powersync/react-native"\nimport { useDatabase } from "app/services/database/database"\nimport { LISTS_TABLE, ListRecord, TODOS_TABLE, TodoRecord } from "app/services/database/schema"\nimport { useAuth } from "app/services/database/use-auth"\nimport { useCallback } from "react"\n\n\nexport function useList(listId: string) {\n  const { user } = useAuth()\n  const { powersync } = useDatabase()\n\n\n  const { data: listRecords } = useQuery<ListRecord>(`\n      SELECT *\n      FROM ${ LISTS_TABLE }\n      WHERE id = ?\n  `, [listId])\n\n  // we only expect one list record\n  const list = listRecords[0]\n\n\n  const { data: todos } = useQuery<TodoRecord>(`\n      SELECT *\n      FROM ${ TODOS_TABtLE }\n      WHERE list_id = ?\n  `, [listId])\n\n\n  const addTodo = useCallback(async (description: string): Promise<{ error: string | null }> => {\n    if (!user) {\n      throw new Error("Can\'t add todo -- user is undefined")\n    }\n    try {\n      await powersync.execute(\n        `INSERT INTO ${ TODOS_TABLE }\n             (id, description, created_at, list_id, created_by, completed)\n         VALUES (uuid(), ?, ?, ?, ?, ?)`,\n        [description, new Date().toISOString(), listId, user?.id, 0],\n      )\n\n      return { error: null }\n    } catch (error: any) {\n      return { error: `Error adding todo: ${ error?.message }` }\n    }\n  }, [user, powersync, listId])\n\n  const removeTodo = useCallback(async (id: string): Promise<{ error: string | null }> => {\n    try {\n      await powersync.execute(`DELETE\n                                FROM ${ TODOS_TABLE }\n                                WHERE id = ?`, [id])\n      return { error: null }\n    } catch (error: any) {\n      console.error("Error removing todo", error)\n      return { error: `Error removing todo: ${ error?.message }` }\n    }\n\n  }, [\n    powersync,\n  ])\n\n  const setTodoCompleted = useCallback(async (id: string, completed: boolean): Promise<{ error: string | null }> => {\n\n    const completedAt = completed ? new Date().toISOString() : null\n    const completedBy = completed ? user?.id : null\n\n    try {\n      await powersync.execute(`\n            UPDATE ${ TODOS_TABLE }\n            SET completed = ?, completed_at = ?, completed_by = ?\n            WHERE id = ?\n        `, [completed, completedAt, completedBy, id])\n\n      return { error: null }\n\n    } catch (error: any) {\n      console.error(\'Error toggling todo\', error)\n      return { error: `Error toggling todo: ${ error?.message }` }\n    }\n  }, [powersync])\n\n\n  return { list, todos, addTodo, removeTodo, setTodoCompleted }\n\n}\n\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"implement-todolistscreen-to-display-and-edit-todos-in-a-list",children:["Implement ",(0,s.jsx)(n.code,{children:"TodoListScreen"})," to Display and Edit Todos in a List"]}),"\n",(0,s.jsxs)(n.p,{children:["Now in our ",(0,s.jsx)(n.code,{children:"TodoList"})," screen we can use the ",(0,s.jsx)(n.code,{children:"useList"})," hook to fetch the todos for a list:"]}),"\n",(0,s.jsxs)(n.p,{children:["A lot of this should be familiar by now, we're using the ",(0,s.jsx)(n.code,{children:"useList"})," hook to fetch the list and todos, and then rendering them in a FlatList."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// app/screens/TodoListScreen.tsx\nimport { Button, Icon, ListItem, Screen, Text, TextField } from "app/components"\nimport { SignedInNavigatorScreenProps } from "app/navigators"\nimport { TodoRecord } from "app/services/database/schema"\nimport { useList } from "app/services/database/use-list"\nimport { colors, spacing } from "app/theme"\nimport React, { FC, useCallback } from "react"\nimport { FlatList, Pressable, TextStyle, View, ViewStyle } from "react-native"\nimport { SafeAreaView } from "react-native-safe-area-context"\n\ninterface TodoListScreenProps extends SignedInNavigatorScreenProps<"TodoList"> {}\n\nexport const TodoListScreen: FC<TodoListScreenProps> = function TodoListScreen({\n  navigation,\n  route: { params: { listId } },\n}) {\n\n  // We use the hook to get the list and todos for the list\n  const { list, todos, addTodo, removeTodo, setTodoCompleted } = useList(listId)\n\n  // State for managing the new todo input and errors\n  const [newTodo, setNewTodo] = React.useState("")\n  const [error, setError] = React.useState<string | null>(null)\n\n  // We wrap the addTodo from the hook with a bit of error handling\n  const handleAddTodo = useCallback(async () => {\n    const { error } = await addTodo(newTodo)\n    if (error) {\n      setError(error)\n      return\n    }\n    setNewTodo("")\n  }, [newTodo])\n\n  // And do the same for removeTodo\n  const handleRemoveTodo = useCallback(async (id: string) => {\n    const { error } = await removeTodo(id)\n    if (error) {\n      setError(error)\n    }\n  }, [removeTodo, setError])\n\n  // We\'ll use the ListItem component to display each todo, as we did with the lists\n  const renderItem = useCallback(({ item }: { item: TodoRecord }) => {\n    return <ListItem\n      containerStyle={ $listItemContainer }\n      textStyle={ [$listItemText, item.completed && $strikeThrough] }\n      text={ `${ item.description }` }\n      RightComponent={ (\n        <Pressable style={ $deleteIcon }>\n          <Icon icon={ "x" } onPress={ () => handleRemoveTodo(item.id) }/>\n        </Pressable>) }\n      onPress={ () => setTodoCompleted(item.id, !item.completed) }\n    />\n  }, [\n    handleRemoveTodo,\n  ])\n\n  return (\n    <Screen style={ $root } preset="fixed">\n      <SafeAreaView style={ $header } edges={ ["top"] }>\n        <Pressable onPress={ () => navigation.goBack() }>\n          <Icon icon={ "back" } size={ 44 }/>\n        </Pressable>\n        <Text style={ $listName } preset={ "heading" } text={ list?.name }/>\n      </SafeAreaView>\n      <View style={ $addTodoContainer }>\n        <Text preset={ "subheading" }>Add a list</Text>\n        <View style={ $form }>\n          <TextField\n            placeholder="New todo..."\n            containerStyle={ $textField }\n            inputWrapperStyle={ $textInput }\n            onChangeText={ setNewTodo }\n            value={ newTodo }/>\n          <Button text="ADD" style={ $button } onPress={ handleAddTodo }/>\n        </View>\n        { error && <Text style={ $error }>{ error }</Text> }\n      </View>\n      <View style={ $container }>\n        <FlatList\n          data={ todos }\n          renderItem={ renderItem }\n          ItemSeparatorComponent={ () => <View style={ $separator }/> }\n          ListEmptyComponent={ <Text style={ $emptyList }>List is Empty</Text> }\n        />\n      </View>\n    </Screen>\n  )\n}\n\nconst $root: ViewStyle = {\n  flex: 1,\n}\nconst $listItemContainer: ViewStyle = {\n  alignItems: "center",\n}\n\nconst $strikeThrough: TextStyle = { textDecorationLine: "line-through" }\n\nconst $form: ViewStyle = {\n  display: "flex",\n  flexDirection: "row",\n  alignItems: "center",\n}\n\nconst $separator: ViewStyle = { height: 1, backgroundColor: colors.border }\n\nconst $emptyList: TextStyle = {\n  color: colors.textDim,\n  opacity: 0.5,\n  padding: spacing.lg,\n  fontSize: 24,\n}\n\nconst $textField: ViewStyle = {\n  flex: 1,\n}\n\nconst $textInput: ViewStyle = {\n  backgroundColor: colors.palette.neutral100,\n}\n\n\nconst $button: ViewStyle = {\n  marginHorizontal: spacing.xs,\n  padding: 0,\n  paddingHorizontal: spacing.xs,\n  paddingVertical: 0,\n}\n\nconst $addTodoContainer: ViewStyle = {\n  padding: spacing.md,\n  backgroundColor: colors.palette.neutral300,\n}\nconst $header: ViewStyle = {\n  display: "flex",\n  flexDirection: "row",\n  alignItems: "center",\n  backgroundColor: colors.palette.secondary200,\n  paddingBottom: spacing.md,\n}\n\nconst $listName: TextStyle = {\n  marginLeft: spacing.sm,\n  flex: 1,\n}\n\nconst $error: TextStyle = {\n  color: colors.error,\n  marginTop: spacing.sm,\n}\n\nconst $container: ViewStyle = {\n  padding: spacing.md,\n}\n\nconst $listItemText: TextStyle = {\n  height: 44,\n  verticalAlign: "middle"\n}\n\nconst $deleteIcon: ViewStyle = {\n  display: "flex",\n  justifyContent: "center",\n  alignItems: "center",\n  height: 44,\n  marginVertical: spacing.xxs,\n}\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"checking-in-2",children:"Checking In"}),"\n",(0,s.jsx)(n.p,{children:"At this point you should be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Touch a list in the ",(0,s.jsx)(n.code,{children:"Lists"})," component and navigate to the ",(0,s.jsx)(n.code,{children:"TodoList"})," screen"]}),"\n",(0,s.jsxs)(n.li,{children:["See the list of todos in the list on the ",(0,s.jsx)(n.code,{children:"TodoList"})," screen"]}),"\n",(0,s.jsx)(n.li,{children:"Add and remove todos from the list"}),"\n",(0,s.jsx)(n.li,{children:"Toggle todos completed status by tapping them"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"congratulations",children:"Congratulations!"}),"\n",(0,s.jsx)(n.p,{children:"Now you have all the tools you need use PowerSync and Supabase to build a local-first app with real-time sync!"})]})}function p(e={}){const{wrapper:n}={...(0,o.M)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},2172:(e,n,t)=>{t.d(n,{I:()=>r,M:()=>i});var s=t(1504);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);